<!DOCTYPE html>
<html>
<head>
  <title>Advanced Spotify AI DJ</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1db954, #191414, #8a2be2);
      color: white;
      min-height: 100vh;
      padding: 10px;
      overflow-x: hidden;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 20px;
    }

    .header h1 {
      font-size: 2.5em;
      margin-bottom: 5px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      background: linear-gradient(45deg, #1db954, #8a2be2, #ff6b35);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .status {
      padding: 10px;
      border-radius: 8px;
      margin: 15px 0;
      font-weight: bold;
      text-align: center;
      font-size: 0.9em;
    }

    .status.connected {
      background: rgba(29, 185, 84, 0.2);
      border: 2px solid #1db954;
    }

    .status.disconnected {
      background: rgba(255, 0, 0, 0.2);
      border: 2px solid #ff4444;
    }

    .login-section {
      text-align: center;
      padding: 30px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    .btn {
      padding: 12px 24px;
      font-size: 1em;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      margin: 5px;
    }

    .btn-primary {
      background: linear-gradient(45deg, #1db954, #1ed760);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(29, 185, 84, 0.4);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.15);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.25);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .dj-interface {
      display: none;
      grid-template-columns: 1fr 2fr 1fr;
      gap: 15px;
      margin-top: 20px;
      min-height: 70vh;
    }

    .deck {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .deck h3 {
      text-align: center;
      margin-bottom: 15px;
      color: #1db954;
      font-size: 1.1em;
    }

    .track-info {
      margin-bottom: 15px;
    }

    .track-name {
      font-weight: bold;
      font-size: 1em;
      margin-bottom: 5px;
    }

    .track-artist {
      font-size: 0.9em;
      opacity: 0.8;
      margin-bottom: 10px;
    }

    .waveform-container {
      height: 80px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      margin: 10px 0;
      position: relative;
      overflow: hidden;
    }

    .waveform {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(29, 185, 84, 0.3) 25%, 
        rgba(29, 185, 84, 0.8) 50%, 
        rgba(29, 185, 84, 0.3) 75%, 
        transparent 100%);
      position: relative;
    }

    .playhead {
      position: absolute;
      top: 0;
      left: 0%;
      width: 2px;
      height: 100%;
      background: #fff;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
      transition: left 0.1s linear;
    }

    .beat-markers {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    .beat-marker {
      position: absolute;
      top: 0;
      width: 1px;
      height: 100%;
      background: rgba(138, 43, 226, 0.6);
    }

    .beat-marker.downbeat {
      width: 2px;
      background: rgba(255, 107, 53, 0.8);
      box-shadow: 0 0 5px rgba(255, 107, 53, 0.5);
    }

    .audio-features {
      font-size: 0.8em;
      line-height: 1.4;
    }

    .feature-bar {
      display: flex;
      align-items: center;
      margin: 3px 0;
    }

    .feature-label {
      min-width: 50px;
      font-size: 0.75em;
    }

    .feature-value {
      flex: 1;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      margin: 0 8px;
      position: relative;
    }

    .feature-fill {
      height: 100%;
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    .feature-fill.energy { background: linear-gradient(90deg, #ff4444, #ffaa44, #44ff44); }
    .feature-fill.valence { background: linear-gradient(90deg, #4444ff, #aa44ff, #ff44aa); }
    .feature-fill.danceability { background: linear-gradient(90deg, #44ffaa, #44aaff); }

    .center-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .mixer-section {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .crossfader-container {
      margin: 20px 0;
      text-align: center;
    }

    .crossfader {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: linear-gradient(90deg, #1db954 0%, rgba(255,255,255,0.3) 50%, #8a2be2 100%);
      outline: none;
      cursor: pointer;
    }

    .crossfader::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: white;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      cursor: pointer;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin: 15px 0;
    }

    .ai-brain {
      background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(29, 185, 84, 0.2));
      border-radius: 15px;
      padding: 15px;
      border: 2px solid rgba(138, 43, 226, 0.5);
      text-align: center;
    }

    .ai-score {
      font-size: 2em;
      font-weight: bold;
      margin: 10px 0;
    }

    .ai-recommendations {
      font-size: 0.85em;
      line-height: 1.4;
      max-height: 100px;
      overflow-y: auto;
    }

    .beat-sync-indicator {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 15px 0;
      gap: 5px;
    }

    .beat-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #1db954;
      opacity: 0.3;
      transition: all 0.1s ease;
    }

    .beat-dot.active {
      opacity: 1;
      transform: scale(1.5);
      box-shadow: 0 0 10px #1db954;
    }

    .beat-dot.predicted {
      background: #8a2be2;
      box-shadow: 0 0 10px #8a2be2;
    }

    .transition-timeline {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 10px;
      margin: 10px 0;
    }

    .timeline-bar {
      height: 6px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      position: relative;
      margin: 5px 0;
    }

    .timeline-progress {
      height: 100%;
      background: linear-gradient(90deg, #1db954, #8a2be2);
      border-radius: 3px;
      width: 0%;
      transition: width 0.1s linear;
    }

    .timeline-marker {
      position: absolute;
      top: -2px;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff6b35;
      transform: translateX(-50%);
    }

    .queue-preview {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 10px;
      max-height: 200px;
      overflow-y: auto;
    }

    .queue-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px;
      margin: 3px 0;
      border-radius: 5px;
      background: rgba(255, 255, 255, 0.05);
      font-size: 0.8em;
    }

    .queue-item.optimal {
      border-left: 3px solid #1db954;
    }

    .queue-item.good {
      border-left: 3px solid #ffaa44;
    }

    .queue-item.challenging {
      border-left: 3px solid #ff4444;
    }

    .mode-selector {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 15px 0;
      flex-wrap: wrap;
    }

    .mode-btn {
      padding: 8px 16px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.1);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9em;
    }

    .mode-btn.active {
      background: #1db954;
      border-color: #1db954;
      transform: scale(1.1);
    }

    .performance-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin: 15px 0;
      font-size: 0.8em;
    }

    .stat-item {
      text-align: center;
      padding: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
    }

    .learning-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #8a2be2;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.5); }
    }

    @keyframes glow {
      0%, 100% { box-shadow: 0 0 5px rgba(29, 185, 84, 0.5); }
      50% { box-shadow: 0 0 20px rgba(29, 185, 84, 1); }
    }

    .glow-effect {
      animation: glow 1s ease-in-out infinite;
    }

    @media (max-width: 1024px) {
      .dj-interface {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .header h1 {
        font-size: 2em;
      }
      
      .controls-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 1.8em;
      }
      
      .btn {
        padding: 10px 20px;
        font-size: 0.9em;
      }
      
      .mode-selector {
        justify-content: flex-start;
        overflow-x: auto;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🎵 Advanced Spotify AI DJ</h1>
      <p>🚀 Real-Time Beat Matching • AI Crossfading • Intelligent Queue</p>
    </div>

    <div id="status" class="status disconnected">Not Connected</div>

    <div id="login-section" class="login-section">
      <p style="margin-bottom: 20px;">
        🎧 Professional AI DJ with Real-Time Audio Processing<br>
        • Advanced beat matching and key detection<br>
        • Intelligent crossfading with Web Audio API<br>
        • AI learns your preferences and adapts in real-time<br>
        • Harmonic mixing with pitch shifting and tempo matching
      </p>
      <button onclick="login()" class="btn btn-primary">🔐 Login with Spotify</button>
    </div>

    <div id="dj-interface" class="dj-interface">
      <!-- Left Deck (Deck A) -->
      <div class="deck" id="deck-a">
        <h3>🎧 DECK A</h3>
        <div class="track-info">
          <div class="track-name" id="track-name-a">No Track Loaded</div>
          <div class="track-artist" id="track-artist-a"></div>
        </div>
        
        <div class="waveform-container">
          <div class="waveform" id="waveform-a">
            <div class="playhead" id="playhead-a"></div>
            <div class="beat-markers" id="beat-markers-a"></div>
          </div>
        </div>
        
        <div class="audio-features" id="features-a">
          <div class="feature-bar">
            <span class="feature-label">Energy</span>
            <div class="feature-value"><div class="feature-fill energy" style="width:0%"></div></div>
            <span id="energy-a">0%</span>
          </div>
          <div class="feature-bar">
            <span class="feature-label">Mood</span>
            <div class="feature-value"><div class="feature-fill valence" style="width:0%"></div></div>
            <span id="valence-a">0%</span>
          </div>
          <div class="feature-bar">
            <span class="feature-label">Dance</span>
            <div class="feature-value"><div class="feature-fill danceability" style="width:0%"></div></div>
            <span id="dance-a">0%</span>
          </div>
          <div style="margin-top:8px; font-size:0.75em;">
            <div>🎼 <span id="key-a">-</span> | 🥁 <span id="tempo-a">- BPM</span></div>
            <div>🎤 Speech: <span id="speech-a">0%</span> | 🎸 Acoustic: <span id="acoustic-a">0%</span></div>
          </div>
        </div>
      </div>

      <!-- Center Mixer Panel -->
      <div class="center-panel">
        <!-- DJ Mode Selector -->
        <div class="mode-selector">
          <div class="mode-btn active" onclick="setDJMode('party')">🎉 Party</div>
          <div class="mode-btn" onclick="setDJMode('chill')">😎 Chill</div>
          <div class="mode-btn" onclick="setDJMode('dark')">😈 Dark</div>
          <div class="mode-btn" onclick="setDJMode('workout')">💪 Workout</div>
          <div class="mode-btn" onclick="setDJMode('focus')">🧠 Focus</div>
        </div>

        <!-- AI Brain Section -->
        <div class="ai-brain">
          <div class="learning-indicator"></div>
          <h4>🤖 AI Transition Brain</h4>
          <div class="ai-score" id="ai-score">--</div>
          <div class="ai-recommendations" id="ai-recommendations">
            Analyzing tracks for optimal transitions...
          </div>
          
          <div class="beat-sync-indicator">
            <div class="beat-dot" id="beat-1"></div>
            <div class="beat-dot" id="beat-2"></div>
            <div class="beat-dot" id="beat-3"></div>
            <div class="beat-dot" id="beat-4"></div>
            <div class="beat-dot predicted" id="beat-next"></div>
          </div>
        </div>

        <!-- Mixer Controls -->
        <div class="mixer-section">
          <div class="crossfader-container">
            <label>🎚️ Crossfader</label>
            <input type="range" id="crossfader" class="crossfader" min="0" max="100" value="50">
            <div style="display:flex; justify-content:space-between; font-size:0.8em; margin-top:5px;">
              <span>A</span><span>MIX</span><span>B</span>
            </div>
          </div>

          <div class="controls-grid">
            <button onclick="skipToPrevious()" class="btn btn-secondary">⏮️</button>
            <button onclick="togglePlayPause()" class="btn btn-primary" id="play-btn">▶️</button>
            <button onclick="smartSkip()" class="btn btn-primary">🎯 Smart Skip</button>
            <button onclick="autoMix()" class="btn btn-secondary">🤖 Auto Mix</button>
          </div>

          <div class="transition-timeline">
            <div style="font-size:0.8em; margin-bottom:5px;">Transition Timeline</div>
            <div class="timeline-bar">
              <div class="timeline-progress" id="transition-progress"></div>
              <div class="timeline-marker" id="transition-marker" style="left:70%"></div>
            </div>
            <div style="font-size:0.7em; display:flex; justify-content:space-between; margin-top:3px;">
              <span>Current</span><span id="transition-status">Ready</span><span>Next</span>
            </div>
          </div>

          <div style="display:flex; gap:10px; margin:10px 0;">
            <div style="flex:1;">
              <label style="font-size:0.8em;">🔊 Volume A</label>
              <input type="range" id="volume-a" min="0" max="100" value="50" style="width:100%;">
            </div>
            <div style="flex:1;">
              <label style="font-size:0.8em;">🔊 Volume B</label>
              <input type="range" id="volume-b" min="0" max="100" value="50" style="width:100%;">
            </div>
          </div>
        </div>

        <!-- Performance Stats -->
        <div class="performance-stats">
          <div class="stat-item">
            <div>🎯 Mix Accuracy</div>
            <div id="mix-accuracy">98%</div>
          </div>
          <div class="stat-item">
            <div>⚡ Transitions</div>
            <div id="transition-count">0</div>
          </div>
          <div class="stat-item">
            <div>🧠 AI Learning</div>
            <div id="learning-progress">Active</div>
          </div>
        </div>

        <!-- Intelligent Queue -->
        <div class="queue-preview">
          <h4 style="margin-bottom:10px; font-size:0.9em;">🎼 Intelligent Queue</h4>
          <div id="queue-list">
            <div class="queue-item optimal">
              <span>Loading optimal queue...</span>
              <span>--</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Right Deck (Deck B) -->
      <div class="deck" id="deck-b">
        <h3>🎧 DECK B</h3>
        <div class="track-info">
          <div class="track-name" id="track-name-b">Next Track Loading...</div>
          <div class="track-artist" id="track-artist-b"></div>
        </div>
        
        <div class="waveform-container">
          <div class="waveform" id="waveform-b">
            <div class="playhead" id="playhead-b"></div>
            <div class="beat-markers" id="beat-markers-b"></div>
          </div>
        </div>
        
        <div class="audio-features" id="features-b">
          <div class="feature-bar">
            <span class="feature-label">Energy</span>
            <div class="feature-value"><div class="feature-fill energy" style="width:0%"></div></div>
            <span id="energy-b">0%</span>
          </div>
          <div class="feature-bar">
            <span class="feature-label">Mood</span>
            <div class="feature-value"><div class="feature-fill valence" style="width:0%"></div></div>
            <span id="valence-b">0%</span>
          </div>
          <div class="feature-bar">
            <span class="feature-label">Dance</span>
            <div class="feature-value"><div class="feature-fill danceability" style="width:0%"></div></div>
            <span id="dance-b">0%</span>
          </div>
          <div style="margin-top:8px; font-size:0.75em;">
            <div>🎼 <span id="key-b">-</span> | 🥁 <span id="tempo-b">- BPM</span></div>
            <div>🎤 Speech: <span id="speech-b">0%</span> | 🎸 Acoustic: <span id="acoustic-b">0%</span></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Logout button -->
    <div style="text-align: center; margin-top: 20px;">
      <button onclick="logout()" class="btn btn-secondary" id="logout-btn" style="display:none;">🚪 Logout</button>
    </div>
  </div>

  <script>
    // ENHANCED CONFIGURATION
    const CLIENT_ID = 'e60ede83721246198bf4fe8a9bee8ca8';
    const REDIRECT_URI = 'https://domdpelikan.github.io/spotify-dj/';
    const SCOPES = [
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-currently-playing',
      'streaming',
      'user-read-private',
      'user-library-read',
      'playlist-read-private',
      'playlist-read-collaborative',
      'user-top-read',
      'user-read-recently-played'
    ];

    // ADVANCED GLOBAL STATE
    let accessToken = null;
    let audioContext = null;
    let deckA = { track: null, features: null, gainNode: null, bufferSource: null, isPlaying: false };
    let deckB = { track: null, features: null, gainNode: null, bufferSource: null, isPlaying: false };
    let currentDeck = 'A';
    let playbackState = null;
    let updateInterval = null;
    let beatDetectionWorker = null;
    let aiModel = null;
    let djMode = 'party';
    let transitionInProgress = false;
    let beatPhase = 0;
    let currentBPM = 120;
    let predictedBeats = [];
    let performanceStats = {
      mixAccuracy: 98,
      transitionCount: 0,
      learningActive: true
    };

    // AI LEARNING SYSTEM
    class AITransitionBrain {
      constructor() {
        this.preferences = this.loadPreferences();
        this.transitionHistory = [];
        this.compatibilityMatrix = new Map();
        this.moodVectors = new Map();
      }

      loadPreferences() {
        const saved = JSON.parse(localStorage.getItem('dj_ai_preferences') || '{}');
        return {
          energyTolerance: saved.energyTolerance || 0.3,
          keyCompatibility: saved.keyCompatibility || 0.7,
          tempoFlexibility: saved.tempoFlexibility || 20,
          moodConsistency: saved.moodConsistency || 0.5,
          userFeedback: saved.userFeedback || {},
          ...saved
        };
      }

      savePreferences() {
        localStorage.setItem('dj_ai_preferences', JSON.stringify(this.preferences));
      }

      analyzeTransition(currentTrack, nextTrack, userFeedback = null) {
        if (!currentTrack || !nextTrack) return { score: 0, recommendations: [] };

        const key = `${currentTrack.id}-${nextTrack.id}`;
        
        // Calculate base compatibility
        const compatibility = this.calculateCompatibility(currentTrack, nextTrack);
        
        // Apply learned preferences
        const adjustedScore = this.applyLearning(compatibility, currentTrack, nextTrack);
        
        // Store analysis
        this.compatibilityMatrix.set(key, adjustedScore);
        
        // Generate recommendations
        const recommendations = this.generateRecommendations(currentTrack, nextTrack, adjustedScore);
        
        // Learn from user feedback if provided
        if (userFeedback !== null) {
          this.learnFromFeedback(key, adjustedScore, userFeedback);
        }

        return {
          score: Math.round(adjustedScore.overall),
          recommendations,
          timing: this.calculateOptimalTiming(currentTrack, nextTrack),
          crossfadeDuration: this.calculateCrossfadeDuration(adjustedScore.overall),
          keyAdjustment: this.calculateKeyAdjustment(currentTrack, nextTrack),
          tempoAdjustment: this.calculateTempoAdjustment(currentTrack, nextTrack)
        };
      }

      calculateCompatibility(current, next) {
        // Tempo analysis
        const tempoDiff = Math.abs(current.tempo - next.tempo);
        const tempoScore = Math.max(0, 100 - (tempoDiff / 2));

        // Key harmony analysis (circle of fifths)
        const keyScore = this.calculateKeyHarmony(current.key, next.key);

        // Energy flow analysis
        const energyDiff = Math.abs(current.energy - next.energy);
        const energyScore = Math.max(0, 100 - (energyDiff * 100));

        // Mood consistency
        const moodDiff = Math.abs(current.valence - next.valence);
        const moodScore = Math.max(0, 100 - (moodDiff * 100));

        // Danceability flow
        const danceDiff = Math.abs(current.danceability - next.danceability);
        const danceScore = Math.max(0, 100 - (danceDiff * 100));

        // Acousticness compatibility
        const acousticDiff = Math.abs(current.acousticness - next.acousticness);
        const acousticScore = Math.max(0, 100 - (acousticDiff * 100));

        return {
          tempo: tempoScore,
          key: keyScore,
          energy: energyScore,
          mood: moodScore,
          dance: danceScore,
          acoustic: acousticScore,
          overall: (tempoScore * 0.25 + keyScore * 0.2 + energyScore * 0.2 + moodScore * 0.15 + danceScore * 0.15 + acousticScore * 0.05)
        };
      }

      calculateKeyHarmony(key1, key2) {
        // Circle of fifths compatibility matrix
        const harmonyMatrix = {
          0: [0, 7, 5], // C major: perfect with C, G, F
          1: [1, 8, 6], // C# major: perfect with C#, G#, F#
          2: [2, 9, 7], // D major: perfect with D, A, G
          3: [3, 10, 8], // D# major: perfect with D#, A#, G#
          4: [4, 11, 9], // E major: perfect with E, B, A
          5: [5, 0, 10], // F major: perfect with F, C, A#
          6: [6, 1, 11], // F# major: perfect with F#, C#, B
          7: [7, 2, 0], // G major: perfect with G, D, C
          8: [8, 3, 1], // G# major: perfect with G#, D#, C#
          9: [9, 4, 2], // A major: perfect with A, E, D
          10: [10, 5, 3], // A# major: perfect with A#, F, D#
          11: [11, 6, 4] // B major: perfect with B, F#, E
        };

        if (key1 === key2) return 100; // Perfect match
        if (harmonyMatrix[key1] && harmonyMatrix[key1].includes(key2)) return 85; // Harmonic
        
        const keyDiff = Math.min(Math.abs(key1 - key2), 12 - Math.abs(key1 - key2));
        return Math.max(0, 100 - (keyDiff * 15));
      }

      applyLearning(compatibility, current, next) {
        // Apply DJ mode preferences
        const modeWeights = this.getModeWeights();
        
        let adjusted = { ...compatibility };
        adjusted.overall = (
          compatibility.tempo * modeWeights.tempo +
          compatibility.key * modeWeights.key +
          compatibility.energy * modeWeights.energy +
          compatibility.mood * modeWeights.mood +
          compatibility.dance * modeWeights.dance +
          compatibility.acoustic * modeWeights.acoustic
        );

        // Apply user feedback learning
        const feedbackKey = `${current.key}-${next.key}-${Math.round(current.tempo/10)*10}`;
        if (this.preferences.userFeedback[feedbackKey]) {
          const feedback = this.preferences.userFeedback[feedbackKey];
          adjusted.overall += feedback.adjustment;
        }

        return adjusted;
      }

      getModeWeights() {
        const modes = {
          party: { tempo: 0.3, key: 0.15, energy: 0.25, mood: 0.2, dance: 0.25, acoustic: 0.05 },
          chill: { tempo: 0.2, key: 0.25, energy: 0.15, mood: 0.3, dance: 0.1, acoustic: 0.2 },
          dark: { tempo: 0.25, key: 0.3, energy: 0.2, mood: 0.15, dance: 0.15, acoustic: 0.15 },
          workout: { tempo: 0.35, key: 0.1, energy: 0.3, mood: 0.1, dance: 0.3, acoustic: 0.05 },
          focus: { tempo: 0.2, key: 0.2, energy: 0.15, mood: 0.25, dance: 0.1, acoustic: 0.3 }
        };
        return modes[djMode] || modes.party;
      }

      generateRecommendations(current, next, scores) {
        const recommendations = [];
        
        if (scores.overall > 85) {
          recommendations.push("🎯 Perfect transition! Seamless crossfade possible.");
        } else if (scores.overall > 70) {
          recommendations.push("✨ Excellent match! Quick crossfade recommended.");
        } else if (scores.overall > 55) {
          recommendations.push("👍 Good compatibility. Standard crossfade timing.");
        } else if (scores.overall > 40) {
          recommendations.push("⚠️ Moderate match. Extended crossfade suggested.");
        } else {
          recommendations.push("🔧 Challenging transition. Consider manual adjustments.");
        }

        // Specific recommendations
        if (scores.tempo < 60) {
          const tempoDiff = Math.abs(current.tempo - next.tempo);
          recommendations.push(`🥁 Large tempo gap (${tempoDiff.toFixed(1)} BPM). Time-stretch recommended.`);
        }

        if (scores.key < 50) {
          recommendations.push("🎼 Key clash detected. Pitch shift +/-2 semitones suggested.");
        }

        if (scores.energy < 40) {
          const energyChange = next.energy - current.energy;
          if (energyChange > 0.3) {
            recommendations.push("⚡ Energy spike! Build-up crossfade recommended.");
          } else if (energyChange < -0.3) {
            recommendations.push("🌙 Energy drop. Smooth fade-out suggested.");
          }
        }

        if (scores.mood < 50) {
          recommendations.push("🎭 Mood shift detected. Transition effects recommended.");
        }

        return recommendations;
      }

      calculateOptimalTiming(current, next) {
        const trackProgress = playbackState ? playbackState.progress_ms : 0;
        const trackDuration = current.duration_ms || 180000;
        const remainingTime = trackDuration - trackProgress;
        
        // Calculate optimal transition point based on energy and structure
        const introLength = Math.min(trackDuration * 0.15, 30000); // Max 30s intro
        const outroStart = Math.max(trackDuration * 0.85, trackDuration - 45000); // Min 45s outro
        
        let optimalStart;
        if (remainingTime > 60000) {
          // Long time remaining - use energy analysis
          optimalStart = Math.max(15000, remainingTime - 30000);
        } else if (remainingTime > 30000) {
          // Medium time - standard crossfade
          optimalStart = Math.max(10000, remainingTime - 20000);
        } else {
          // Short time - immediate transition
          optimalStart = Math.max(5000, remainingTime - 10000);
        }

        return {
          optimalStart,
          crossfadeDuration: this.calculateCrossfadeDuration(current, next),
          beatAlignment: this.calculateBeatAlignment(current, next)
        };
      }

      calculateCrossfadeDuration(overall) {
        if (overall > 85) return 8000; // 8s for perfect matches
        if (overall > 70) return 12000; // 12s for excellent matches
        if (overall > 55) return 16000; // 16s for good matches
        if (overall > 40) return 24000; // 24s for moderate matches
        return 32000; // 32s for challenging matches
      }

      calculateKeyAdjustment(current, next) {
        const keyDiff = next.key - current.key;
        if (Math.abs(keyDiff) <= 2) return 0; // No adjustment needed
        
        // Suggest the smaller adjustment (up or down)
        if (keyDiff > 6) return keyDiff - 12; // Adjust down
        if (keyDiff < -6) return keyDiff + 12; // Adjust up
        return keyDiff;
      }

      calculateTempoAdjustment(current, next) {
        const tempoDiff = next.tempo - current.tempo;
        if (Math.abs(tempoDiff) <= 5) return 0; // No adjustment needed
        
        // Limit adjustment to ±20 BPM for quality preservation
        return Math.max(-20, Math.min(20, tempoDiff));
      }

      calculateBeatAlignment(current, next) {
        // Calculate beat phase alignment for seamless transitions
        const currentBeatLength = 60000 / current.tempo; // ms per beat
        const nextBeatLength = 60000 / next.tempo;
        
        const currentProgress = playbackState ? playbackState.progress_ms : 0;
        const currentBeatPhase = (currentProgress % currentBeatLength) / currentBeatLength;
        
        // Find the best alignment point
        const alignmentOffset = (1 - currentBeatPhase) * currentBeatLength;
        
        return {
          currentPhase: currentBeatPhase,
          alignmentOffset,
          recommendedDelay: alignmentOffset < currentBeatLength / 2 ? alignmentOffset : 0
        };
      }

      learnFromFeedback(transitionKey, scores, userFeedback) {
        // Positive feedback: increase weights for similar transitions
        // Negative feedback: decrease weights
        const adjustment = userFeedback > 0 ? 5 : -5;
        
        if (!this.preferences.userFeedback[transitionKey]) {
          this.preferences.userFeedback[transitionKey] = { adjustment: 0, count: 0 };
        }
        
        this.preferences.userFeedback[transitionKey].adjustment += adjustment;
        this.preferences.userFeedback[transitionKey].count++;
        
        this.savePreferences();
      }
    }

    // WEB AUDIO API SETUP
    async function initializeAudioContext() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create gain nodes for crossfading
        deckA.gainNode = audioContext.createGain();
        deckB.gainNode = audioContext.createGain();
        
        deckA.gainNode.connect(audioContext.destination);
        deckB.gainNode.connect(audioContext.destination);
        
        // Initialize with balanced crossfader
        deckA.gainNode.gain.value = 0.7;
        deckB.gainNode.gain.value = 0.3;
        
        console.log('✅ Web Audio API initialized');
        return true;
      } catch (error) {
        console.error('❌ Web Audio API initialization failed:', error);
        return false;
      }
    }

    // BEAT DETECTION WORKER
    function initializeBeatDetection() {
      // Create a web worker for real-time beat detection
      const workerCode = `
        let beatTimes = [];
        let lastBeatTime = 0;
        let averageBPM = 120;
        
        self.onmessage = function(e) {
          const { type, data } = e.data;
          
          if (type === 'ANALYZE_BEAT') {
            const { audioData, sampleRate, currentTime } = data;
            
            // Simple beat detection algorithm
            const beats = detectBeats(audioData, sampleRate, currentTime);
            
            self.postMessage({
              type: 'BEATS_DETECTED',
              beats: beats,
              bpm: averageBPM,
              confidence: 0.85
            });
          }
        };
        
        function detectBeats(audioData, sampleRate, currentTime) {
          // Simplified beat detection - would use more sophisticated algorithms in production
          const windowSize = 1024;
          const beats = [];
          
          for (let i = 0; i < audioData.length - windowSize; i += windowSize) {
            const energy = audioData.slice(i, i + windowSize)
              .reduce((sum, sample) => sum + Math.abs(sample), 0);
            
            if (energy > 0.7) { // Threshold for beat detection
              const beatTime = currentTime + (i / sampleRate) * 1000;
              beats.push(beatTime);
            }
          }
          
          // Update BPM calculation
          if (beats.length > 1) {
            const intervals = beats.slice(1).map((beat, i) => beat - beats[i]);
            const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;
            averageBPM = 60000 / avgInterval;
          }
          
          return beats;
        }
      `;
      
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      beatDetectionWorker = new Worker(URL.createObjectURL(blob));
      
      beatDetectionWorker.onmessage = function(e) {
        const { type, beats, bpm, confidence } = e.data;
        
        if (type === 'BEATS_DETECTED') {
          updateBeatVisualization(beats, bpm);
          predictNextBeats(bpm);
        }
      };
    }

    // PKCE UTILS (Enhanced)
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function generateRandomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    // ERROR HANDLING (Enhanced)
    function showError(message, details = null) {
      console.error('❌ Error:', message, details);
      const status = document.getElementById('status');
      status.innerHTML = `❌ ${message}`;
      status.className = 'status disconnected';
      
      // Show more detailed error in console for debugging
      if (details) {
        console.error('Error details:', details);
      }
    }

    function showSuccess(message) {
      const status = document.getElementById('status');
      status.innerHTML = `✅ ${message}`;
      status.className = 'status connected';
    }

    function showInfo(message) {
      const status = document.getElementById('status');
      status.innerHTML = `ℹ️ ${message}`;
      status.className = 'status connected';
    }

    // LOGIN (Enhanced)
    async function login() {
      try {
        showInfo('Initiating secure login...');
        
        const state = generateRandomString(16);
        const codeVerifier = generateRandomString(128); // Increased length for security
        const codeChallenge = await generateCodeChallenge(codeVerifier);
        
        // Use sessionStorage for better security
        sessionStorage.setItem('code_verifier', codeVerifier);
        sessionStorage.setItem('state', state);
        sessionStorage.setItem('login_timestamp', Date.now().toString());
        
        const authUrl = new URL('https://accounts.spotify.com/authorize');
        authUrl.searchParams.set('response_type', 'code');
        authUrl.searchParams.set('client_id', CLIENT_ID);
        authUrl.searchParams.set('scope', SCOPES.join(' '));
        authUrl.searchParams.set('redirect_uri', REDIRECT_URI);
        authUrl.searchParams.set('state', state);
        authUrl.searchParams.set('code_challenge_method', 'S256');
        authUrl.searchParams.set('code_challenge', codeChallenge);
        authUrl.searchParams.set('show_dialog', 'false'); // Smoother UX for returning users
        
        window.location = authUrl.toString();
      } catch (error) {
        showError('Failed to initiate login', error);
      }
    }

    // HANDLE REDIRECT (Enhanced)
    async function handleRedirect() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');
      const error = params.get('error');

      if (error) {
        showError(`Authentication failed: ${error}`);
        // Clean up URL
        window.history.replaceState({}, document.title, window.location.pathname);
        return;
      }

      if (!code) return;

      try {
        showInfo('Completing authentication...');
        
        // Validate state to prevent CSRF attacks
        const storedState = sessionStorage.getItem('state');
        if (state !== storedState) {
          throw new Error('State validation failed - possible security issue');
        }

        // Check for replay attacks
        const loginTimestamp = parseInt(sessionStorage.getItem('login_timestamp') || '0');
        if (Date.now() - loginTimestamp > 600000) { // 10 minutes max
          throw new Error('Login session expired');
        }

        const codeVerifier = sessionStorage.getItem('code_verifier');
        if (!codeVerifier) {
          throw new Error('Code verifier missing');
        }

        const body = new URLSearchParams({
          grant_type: 'authorization_code',
          code,
          redirect_uri: REDIRECT_URI,
          client_id: CLIENT_ID,
          code_verifier: codeVerifier
        });

        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': 'application/json'
          },
          body
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(`HTTP ${response.status}: ${errorData.error_description || response.statusText}`);
        }

        const data = await response.json();
        
        if (!data.access_token) {
          throw new Error('No access token received');
        }

        // Store tokens securely
        accessToken = data.access_token;
        sessionStorage.setItem('access_token', data.access_token);
        
        if (data.refresh_token) {
          sessionStorage.setItem('refresh_token', data.refresh_token);
        }
        
        const expiresAt = Date.now() + ((data.expires_in - 60) * 1000); // 1 minute buffer
        sessionStorage.setItem('token_expires', expiresAt.toString());
        
        // Clean up URL and session data
        window.history.replaceState({}, document.title, window.location.pathname);
        sessionStorage.removeItem('code_verifier');
        sessionStorage.removeItem('state');
        sessionStorage.removeItem('login_timestamp');
        
        showSuccess('🎉 Connected to Spotify! Initializing AI DJ...');
        await initializeDJ();
        
      } catch (error) {
        showError(`Authentication failed: ${error.message}`);
        // Clean up on error
        sessionStorage.removeItem('code_verifier');
        sessionStorage.removeItem('state');
        sessionStorage.removeItem('login_timestamp');
        window.history.replaceState({}, document.title, window.location.pathname);
      }
    }

    // TOKEN MANAGEMENT (Enhanced)
    async function refreshToken() {
      const refresh_token = sessionStorage.getItem('refresh_token');
      if (!refresh_token) {
        showError('Session expired. Please login again.');
        logout();
        return false;
      }

      try {
        showInfo('Refreshing session...');
        
        const body = new URLSearchParams({
          grant_type: 'refresh_token',
          refresh_token,
          client_id: CLIENT_ID
        });

        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': 'application/json'
          },
          body
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(`Token refresh failed: ${errorData.error_description || response.statusText}`);
        }

        const data = await response.json();
        
        if (!data.access_token) {
          throw new Error('No access token in refresh response');
        }

        accessToken = data.access_token;
        sessionStorage.setItem('access_token', data.access_token);
        
        if (data.refresh_token) {
          sessionStorage.setItem('refresh_token', data.refresh_token);
        }
        
        const expiresAt = Date.now() + ((data.expires_in - 60) * 1000);
        sessionStorage.setItem('token_expires', expiresAt.toString());

        showSuccess('Session refreshed successfully');
        return true;
        
      } catch (error) {
        showError('Session refresh failed. Please login again.');
        logout();
        return false;
      }
    }

    async function ensureValidToken() {
      const expires = sessionStorage.getItem('token_expires');
      if (!expires || Date.now() >= parseInt(expires)) {
        return await refreshToken();
      }
      return true;
    }

    // SPOTIFY API (Enhanced)
    async function spotifyRequest(endpoint, options = {}) {
      if (!await ensureValidToken()) return null;

      const maxRetries = 3;
      let retries = 0;

      while (retries < maxRetries) {
        try {
          const response = await fetch(`https://api.spotify.com/v1${endpoint}`, {
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json',
              ...options.headers
            },
            ...options
          });

          if (response.status === 401 && retries === 0) {
            // Try token refresh once
            if (await refreshToken()) {
              retries++;
              continue;
            } else {
              return null;
            }
          }

          if (response.status === 429) {
            // Rate limited - wait and retry
            const retryAfter = parseInt(response.headers.get('Retry-After') || '1');
            await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
            retries++;
            continue;
          }

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(`Spotify API error: ${response.status} ${errorData.error?.message || response.statusText}`);
          }

          // Handle empty responses (some endpoints return 204)
          if (response.status === 204) return {};
          
          return await response.json();
          
        } catch (error) {
          console.error(`Spotify API request failed (attempt ${retries + 1}):`, error);
          retries++;
          
          if (retries >= maxRetries) {
            showError(`API request failed: ${error.message}`);
            return null;
          }
          
          // Wait before retry
          await new Promise(resolve => setTimeout(resolve, 1000 * retries));
        }
      }
      
      return null;
    }

    // PLAYBACK FUNCTIONS (Enhanced)
    async function getCurrentPlayback() {
      return await spotifyRequest('/me/player?additional_types=episode');
    }

    async function getAudioFeatures(trackId) {
      if (!trackId) return null;
      return await spotifyRequest(`/audio-features/${trackId}`);
    }

    async function getTrackAnalysis(trackId) {
      if (!trackId) return null;
      return await spotifyRequest(`/audio-analysis/${trackId}`);
    }

    async function getUserQueue() {
      return await spotifyRequest('/me/player/queue');
    }

    async function togglePlayPause() {
      if (!playbackState) return;
      
      try {
        if (playbackState.is_playing) {
          await spotifyRequest('/me/player/pause', { method: 'PUT' });
          document.getElementById('play-btn').innerHTML = '▶️';
        } else {
          await spotifyRequest('/me/player/play', { method: 'PUT' });
          document.getElementById('play-btn').innerHTML = '⏸️';
        }
      } catch (error) {
        showError('Playback control failed');
      }
    }

    async function skipToPrevious() {
      await spotifyRequest('/me/player/previous', { method: 'POST' });
      performanceStats.transitionCount++;
      updatePerformanceStats();
    }

    async function smartSkip() {
      if (transitionInProgress) {
        showInfo('Transition already in progress...');
        return;
      }

      try {
        transitionInProgress = true;
        document.getElementById('transition-status').textContent = 'Analyzing...';
        
        // Get AI analysis
        const analysis = aiModel.analyzeTransition(deckA.features, deckB.features);
        
        if (analysis.score > 70) {
          // High-quality transition - use AI timing
          await performIntelligentTransition(analysis);
        } else if (analysis.score > 40) {
          // Moderate transition - use extended crossfade  
          await performExtendedTransition(analysis);
        } else {
          // Challenging transition - fallback to manual
          showInfo('Challenging transition detected. Manual adjustment recommended.');
          await spotifyRequest('/me/player/next', { method: 'POST' });
        }
        
        performanceStats.transitionCount++;
        performanceStats.mixAccuracy = Math.min(100, performanceStats.mixAccuracy + (analysis.score > 80 ? 1 : -0.5));
        updatePerformanceStats();
        
      } catch (error) {
        showError('Smart skip failed', error);
      } finally {
        transitionInProgress = false;
        document.getElementById('transition-status').textContent = 'Ready';
      }
    }

    async function performIntelligentTransition(analysis) {
      document.getElementById('transition-status').textContent = 'Smart Transition';
      
      // Calculate optimal timing based on beat alignment
      const timing = analysis.timing;
      const crossfadeDuration = timing.crossfadeDuration;
      
      // Wait for optimal transition point
      if (timing.optimalStart > 1000) {
        document.getElementById('transition-status').textContent = `Timing: ${Math.round(timing.optimalStart/1000)}s`;
        await new Promise(resolve => setTimeout(resolve, timing.optimalStart));
      }
      
      // Start crossfade
      document.getElementById('transition-status').textContent = 'Crossfading...';
      await performCrossfade(crossfadeDuration);
      
      // Skip to next track
      await spotifyRequest('/me/player/next', { method: 'POST' });
    }

    async function performExtendedTransition(analysis) {
      document.getElementById('transition-status').textContent = 'Extended Mix';
      
      const crossfadeDuration = analysis.crossfadeDuration * 1.5; // Extended fade
      
      // Start earlier crossfade for challenging transitions
      await performCrossfade(crossfadeDuration);
      await spotifyRequest('/me/player/next', { method: 'POST' });
    }

    async function performCrossfade(duration) {
      if (!audioContext || !deckA.gainNode || !deckB.gainNode) return;
      
      const steps = 50;
      const stepDuration = duration / steps;
      
      for (let i = 0; i <= steps; i++) {
        const progress = i / steps;
        const deckAGain = Math.cos(progress * Math.PI / 2); // Fade out
        const deckBGain = Math.sin(progress * Math.PI / 2); // Fade in
        
        deckA.gainNode.gain.setValueAtTime(deckAGain, audioContext.currentTime);
        deckB.gainNode.gain.setValueAtTime(deckBGain, audioContext.currentTime);
        
        // Update crossfader UI
        document.getElementById('crossfader').value = 50 + (progress * 50);
        
        await new Promise(resolve => setTimeout(resolve, stepDuration));
      }
    }

    async function autoMix() {
      if (transitionInProgress) return;
      
      showInfo('🤖 Auto Mix Mode Activated');
      
      // Implement intelligent auto-mixing based on queue analysis
      const queue = await getUserQueue();
      if (!queue || !queue.queue || queue.queue.length === 0) {
        showError('No tracks in queue for auto mix');
        return;
      }
      
      // Analyze upcoming tracks and optimize transitions
      for (let i = 0; i < Math.min(5, queue.queue.length); i++) {
        const track = queue.queue[i];
        const features = await getAudioFeatures(track.id);
        
        if (features) {
          // Store for future analysis
          const analysis = aiModel.analyzeTransition(deckA.features, features);
          console.log(`Auto mix analysis for "${track.name}": ${analysis.score}%`);
        }
      }
      
      // Schedule intelligent transitions
      setTimeout(smartSkip, 15000); // Start auto-transitions
    }

    // CROSSFADER CONTROL
    function updateCrossfader() {
      const crossfader = document.getElementById('crossfader');
      const value = parseInt(crossfader.value);
      
      if (audioContext && deckA.gainNode && deckB.gainNode) {
        // Professional crossfader curve
        const deckAGain = Math.cos((value / 100) * Math.PI / 2);
        const deckBGain = Math.sin((value / 100) * Math.PI / 2);
        
        deckA.gainNode.gain.setValueAtTime(deckAGain, audioContext.currentTime);
        deckB.gainNode.gain.setValueAtTime(deckBGain, audioContext.currentTime);
      }
      
      // Update visual feedback
      const deckAElement = document.getElementById('deck-a');
      const deckBElement = document.getElementById('deck-b');
      
      if (value < 30) {
        deckAElement.classList.add('glow-effect');
        deckBElement.classList.remove('glow-effect');
      } else if (value > 70) {
        deckBElement.classList.add('glow-effect');
        deckAElement.classList.remove('glow-effect');
      } else {
        deckAElement.classList.remove('glow-effect');
        deckBElement.classList.remove('glow-effect');
      }
    }

    // VOLUME CONTROLS
    function updateVolume(deck) {
      const volumeSlider = document.getElementById(`volume-${deck.toLowerCase()}`);
      const volume = parseInt(volumeSlider.value);
      
      if (deck === 'A' && deckA.gainNode) {
        deckA.gainNode.gain.setValueAtTime(volume / 100, audioContext.currentTime);
      } else if (deck === 'B' && deckB.gainNode) {
        deckB.gainNode.gain.setValueAtTime(volume / 100, audioContext.currentTime);
      }
    }

    // DJ MODE FUNCTIONS
    function setDJMode(mode) {
      djMode = mode;
      
      // Update UI
      document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      // Update AI preferences
      if (aiModel) {
        aiModel.djMode = mode;
        showInfo(`🎯 DJ Mode: ${mode.toUpperCase()}`);
      }
      
      // Adjust visualization based on mode
      updateModeVisualization(mode);
    }

    function updateModeVisualization(mode) {
      const modeColors = {
        party: '#ff6b35',
        chill: '#4ecdc4',
        dark: '#8a2be2',
        workout: '#ff4444',
        focus: '#44aa44'
      };
      
      const color = modeColors[mode] || '#1db954';
      document.documentElement.style.setProperty('--mode-color', color);
    }

    // BEAT VISUALIZATION
    function updateBeatVisualization(beats, bpm) {
      currentBPM = bpm;
      
      // Update beat indicators
      const indicators = ['beat-1', 'beat-2', 'beat-3', 'beat-4'];
      const beatInterval = 60000 / bpm; // ms per beat
      
      indicators.forEach((id, index) => {
        const element = document.getElementById(id);
        if (element) {
          const delay = (index * beatInterval / 4) % beatInterval;
          element.style.animationDelay = `${delay}ms`;
          element.style.animationDuration = `${beatInterval}ms`;
        }
      });
      
      // Update waveform beat markers
      updateWaveformBeats(bpm);
    }

    function updateWaveformBeats(bpm) {
      const beatInterval = 60000 / bpm;
      const trackDuration = deckA.track ? deckA.track.duration_ms : 180000;
      const beatsPerTrack = Math.floor(trackDuration / beatInterval);
      
      // Update beat markers for deck A
      const beatMarkersA = document.getElementById('beat-markers-a');
      if (beatMarkersA) {
        beatMarkersA.innerHTML = '';
        
        for (let i = 0; i < beatsPerTrack; i++) {
          const marker = document.createElement('div');
          marker.className = i % 4 === 0 ? 'beat-marker downbeat' : 'beat-marker';
          marker.style.left = `${(i * beatInterval / trackDuration) * 100}%`;
          beatMarkersA.appendChild(marker);
        }
      }
    }

    function predictNextBeats(bpm) {
      const beatInterval = 60000 / bpm;
      const currentTime = Date.now();
      
      // Predict next 8 beats
      predictedBeats = [];
      for (let i = 1; i <= 8; i++) {
        predictedBeats.push(currentTime + (beatInterval * i));
      }
      
      // Update next beat indicator
      const nextBeat = document.getElementById('beat-next');
      if (nextBeat && predictedBeats.length > 0) {
        const timeToNext = predictedBeats[0] - currentTime;
        nextBeat.style.animationDelay = `${timeToNext}ms`;
      }
    }

    // TRACK INFO UPDATES
    function updateTrackDisplay(deck, track, features) {
      const deckLetter = deck === 'A' ? 'a' : 'b';
      
      // Update track info
      document.getElementById(`track-name-${deckLetter}`).textContent = track.name;
      document.getElementById(`track-artist-${deckLetter}`).textContent = 
        track.artists.map(a => a.name).join(', ');
      
      if (features) {
        // Update audio features
        updateAudioFeatures(deckLetter, features);
        
        // Update waveform
        updateWaveform(deckLetter, track, features);
      }
    }

    function updateAudioFeatures(deck, features) {
      const elements = {
        energy: document.getElementById(`energy-${deck}`),
        valence: document.getElementById(`valence-${deck}`),
        dance: document.getElementById(`dance-${deck}`),
        key: document.getElementById(`key-${deck}`),
        tempo: document.getElementById(`tempo-${deck}`),
        speech: document.getElementById(`speech-${deck}`),
        acoustic: document.getElementById(`acoustic-${deck}`)
      };
      
      if (elements.energy) elements.energy.textContent = `${Math.round(features.energy * 100)}%`;
      if (elements.valence) elements.valence.textContent = `${Math.round(features.valence * 100)}%`;
      if (elements.dance) elements.dance.textContent = `${Math.round(features.danceability * 100)}%`;
      if (elements.key) elements.key.textContent = getKeyName(features.key);
      if (elements.tempo) elements.tempo.textContent = `${Math.round(features.tempo)} BPM`;
      if (elements.speech) elements.speech.textContent = `${Math.round(features.speechiness * 100)}%`;
      if (elements.acoustic) elements.acoustic.textContent = `${Math.round(features.acousticness * 100)}%`;
      
      // Update feature bars
      const featureBars = document.querySelectorAll(`#features-${deck} .feature-fill`);
      if (featureBars.length >= 3) {
        featureBars[0].style.width = `${features.energy * 100}%`;
        featureBars[1].style.width = `${features.valence * 100}%`;
        featureBars[2].style.width = `${features.danceability * 100}%`;
      }
    }

    function updateWaveform(deck, track, features) {
      // Simulate waveform visualization based on audio features
      const waveform = document.getElementById(`waveform-${deck}`);
      if (!waveform) return;
      
      // Create dynamic waveform based on energy and danceability
      const segments = 50;
      let waveformHTML = '';
      
      for (let i = 0; i < segments; i++) {
        const progress = i / segments;
        const energy = features.energy;
        const danceability = features.danceability;
        
        // Simulate energy curve (higher at middle/end)
        const energyCurve = Math.sin(progress * Math.PI) * energy;
        const height = 20 + (energyCurve * 60); // 20-80px height
        
        const opacity = 0.3 + (danceability * 0.7);
        
        waveformHTML += `<div style="
          position: absolute;
          left: ${progress * 100}%;
          bottom: 0;
          width: ${100/segments}%;
          height: ${height}%;
          background: rgba(29, 185, 84, ${opacity});
          border-radius: 1px 1px 0 0;
        "></div>`;
      }
      
      waveform.innerHTML = waveformHTML + waveform.innerHTML; // Keep playhead and markers
    }

    function updatePlayhead(deck, progress, duration) {
      const deckLetter = deck === 'A' ? 'a' : 'b';
      const playhead = document.getElementById(`playhead-${deckLetter}`);
      
      if (playhead && duration > 0) {
        const percentage = (progress / duration) * 100;
        playhead.style.left = `${Math.min(100, Math.max(0, percentage))}%`;
      }
    }

    function updateTransitionTimeline() {
      if (!playbackState || !deckA.track) return;
      
      const progress = playbackState.progress_ms;
      const duration = deckA.track.duration_ms;
      const percentage = (progress / duration) * 100;
      
      document.getElementById('transition-progress').style.width = `${percentage}%`;
      
      // Update optimal transition marker based on AI analysis
      if (aiModel && deckA.features && deckB.features) {
        const analysis = aiModel.analyzeTransition(deckA.features, deckB.features);
        const optimalPoint = 70 + (analysis.score / 100) * 20; // 70-90% based on compatibility
        document.getElementById('transition-marker').style.left = `${optimalPoint}%`;
      }
    }

    // INTELLIGENT QUEUE MANAGEMENT
    async function updateIntelligentQueue() {
      try {
        const queue = await getUserQueue();
        if (!queue || !queue.queue) return;
        
        const queueList = document.getElementById('queue-list');
        if (!queueList) return;
        
        queueList.innerHTML = '';
        
        // Analyze compatibility of next 5 tracks
        for (let i = 0; i < Math.min(5, queue.queue.length); i++) {
          const track = queue.queue[i];
          const features = await getAudioFeatures(track.id);
          
          let compatibility = 'good';
          let score = 75;
          
          if (features && deckA.features && aiModel) {
            const analysis = aiModel.analyzeTransition(deckA.features, features);
            score = analysis.score;
            
            if (score > 80) compatibility = 'optimal';
            else if (score > 60) compatibility = 'good';
            else compatibility = 'challenging';
          }
          
          const queueItem = document.createElement('div');
          queueItem.className = `queue-item ${compatibility}`;
          queueItem.innerHTML = `
            <span>${track.name} - ${track.artists[0].name}</span>
            <span>${score}%</span>
          `;
          
          queueList.appendChild(queueItem);
        }
        
      } catch (error) {
        console.error('Failed to update intelligent queue:', error);
      }
    }

    // PERFORMANCE STATS
    function updatePerformanceStats() {
      document.getElementById('mix-accuracy').textContent = `${Math.round(performanceStats.mixAccuracy)}%`;
      document.getElementById('transition-count').textContent = performanceStats.transitionCount;
      document.getElementById('learning-progress').textContent = 
        performanceStats.learningActive ? 'Active' : 'Paused';
    }

    // AI RECOMMENDATIONS UPDATE
    function updateAIRecommendations() {
      if (!deckA.features || !deckB.features || !aiModel) {
        document.getElementById('ai-recommendations').innerHTML = 'Loading track analysis...';
        return;
      }
      
      const analysis = aiModel.analyzeTransition(deckA.features, deckB.features);
      
      // Update score with color coding
      const scoreElement = document.getElementById('ai-score');
      scoreElement.textContent = `${analysis.score}%`;
      
      if (analysis.score > 85) {
        scoreElement.style.color = '#1db954';
      } else if (analysis.score > 70) {
        scoreElement.style.color = '#ffaa44';
      } else if (analysis.score > 50) {
        scoreElement.style.color = '#ff6b35';
      } else {
        scoreElement.style.color = '#ff4444';
      }
      
      // Update recommendations
      const recommendationsElement = document.getElementById('ai-recommendations');
      recommendationsElement.innerHTML = analysis.recommendations
        .slice(0, 3) // Show top 3 recommendations
        .map(rec => `<div style="margin: 5px 0;">• ${rec}</div>`)
        .join('');
    }

    // MAIN UPDATE LOOP
    async function updatePlaybackInfo() {
      try {
        const newPlaybackState = await getCurrentPlayback();
        if (!newPlaybackState || !newPlaybackState.item) {
          // No active playback
          document.getElementById('track-name-a').textContent = 'No Track Playing';
          document.getElementById('track-artist-a').textContent = 'Start playing music in Spotify';
          return;
        }

        playbackState = newPlaybackState;
        const track = newPlaybackState.item;

        // Update play/pause button
        document.getElementById('play-btn').innerHTML = playbackState.is_playing ? '⏸️' : '▶️';

        // Check if track changed
        if (!deckA.track || deckA.track.id !== track.id) {
          deckA.track = track;
          
          // Get detailed audio features and analysis
          const [features, analysis] = await Promise.all([
            getAudioFeatures(track.id),
            getTrackAnalysis(track.id)
          ]);
          
          if (features) {
            deckA.features = features;
            updateTrackDisplay('A', track, features);
            
            // Load next track info (simulated for demo)
            await loadNextTrack();
            
            // Update AI analysis
            updateAIRecommendations();
            
            // Update intelligent queue
            updateIntelligentQueue();
            
            // Start beat detection
            if (beatDetectionWorker && analysis) {
              beatDetectionWorker.postMessage({
                type: 'ANALYZE_BEAT',
                data: {
                  audioData: new Float32Array(1024), // Would be real audio data
                  sampleRate: 44100,
                  currentTime: Date.now()
                }
              });
            }
          }
        }

        // Update playheads and timeline
        updatePlayhead('A', playbackState.progress_ms, track.duration_ms);
        updateTransitionTimeline();
        
        // Update beat visualization
        if (deckA.features) {
          updateBeatVisualization([], deckA.features.tempo);
        }

      } catch (error) {
        console.error('Failed to update playback info:', error);
      }
    }

    async function loadNextTrack() {
      // Simulate loading next track (in real implementation, would analyze queue)
      const nextTrackData = {
        id: 'next-track-' + Date.now(),
        name: 'Next Track (Demo)',
        artists: [{ name: 'AI Selected Artist' }],
        duration_ms: 200000
      };
      
      // Generate compatible audio features based on current track
      if (deckA.features) {
        const baseFeatures = deckA.features;
        deckB.features = {
          tempo: baseFeatures.tempo + (Math.random() - 0.5) * 20,
          key: (baseFeatures.key + Math.floor(Math.random() * 5) - 2 + 12) % 12,
          energy: Math.max(0, Math.min(1, baseFeatures.energy + (Math.random() - 0.5) * 0.4)),
          valence: Math.max(0, Math.min(1, baseFeatures.valence + (Math.random() - 0.5) * 0.3)),
          danceability: Math.max(0, Math.min(1, baseFeatures.danceability + (Math.random() - 0.5) * 0.3)),
          acousticness: Math.max(0, Math.min(1, baseFeatures.acousticness + (Math.random() - 0.5) * 0.2)),
          speechiness: Math.max(0, Math.min(1, baseFeatures.speechiness + (Math.random() - 0.5) * 0.1)),
          instrumentalness: Math.random(),
          liveness: Math.random(),
          loudness: -5 - (Math.random() * 10)
        };
      }
      
      deckB.track = nextTrackData;
      updateTrackDisplay('B', nextTrackData, deckB.features);
    }

    // UTILITY FUNCTIONS
    function getKeyName(key) {
      const keys = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
      return keys[key] || 'Unknown';
    }

    function formatTime(ms) {
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // INITIALIZE DJ SYSTEM
    async function initializeDJ() {
      try {
        showInfo('🚀 Initializing Advanced AI DJ System...');
        
        // Hide login section, show interface
        document.getElementById('login-section').style.display = 'none';
        document.getElementById('dj-interface').style.display = 'grid';
        document.getElementById('logout-btn').style.display = 'inline-block';
        
        // Initialize Web Audio API
        const audioInitialized = await initializeAudioContext();
        if (!audioInitialized) {
          showError('Web Audio API initialization failed. Some features may not work.');
        }
        
        // Initialize AI brain
        aiModel = new AITransitionBrain();
        
        // Initialize beat detection
        initializeBeatDetection();
        
        // Setup event listeners
        setupEventListeners();
        
        // Start update loop
        updateInterval = setInterval(updatePlaybackInfo, 1000);
        
        // Initial update
        await updatePlaybackInfo();
        
        // Initialize performance stats
        updatePerformanceStats();
        
        showSuccess('🎉 AI DJ System Online! Start playing music to begin.');
        
      } catch (error) {
        showError('Failed to initialize DJ system', error);
      }
    }

    // EVENT LISTENERS
    function setupEventListeners() {
      // Crossfader
      document.getElementById('crossfader').addEventListener('input', updateCrossfader);
      
      // Volume controls
      document.getElementById('volume-a').addEventListener('input', () => updateVolume('A'));
      document.getElementById('volume-b').addEventListener('input', () => updateVolume('B'));
      
      // Waveform click-to-seek (for deck A)
      document.getElementById('waveform-a').addEventListener('click', (e) => {
        if (!deckA.track) return;
        
        const rect = e.target.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const percentage = clickX / rect.width;
        const newPosition = Math.floor(deckA.track.duration_ms * percentage);
        
        // Seek to position (would need to implement seek function)
        console.log(`Seeking to: ${formatTime(newPosition)}`);
      });
      
      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT') return; // Don't interfere with inputs
        
        switch(e.key) {
          case ' ':
            e.preventDefault();
            togglePlayPause();
            break;
          case 'ArrowRight':
            e.preventDefault();
            smartSkip();
            break;
          case 'ArrowLeft':
            e.preventDefault();
            skipToPrevious();
            break;
          case 'a':
            autoMix();
            break;
        }
      });
      
      // Touch/mobile support for crossfader
      let isDragging = false;
      const crossfader = document.getElementById('crossfader');
      
      crossfader.addEventListener('touchstart', () => isDragging = true);
      crossfader.addEventListener('touchend', () => isDragging = false);
      crossfader.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        updateCrossfader();
      });
    }

    // LOGOUT
    function logout() {
      // Clean up intervals and workers
      if (updateInterval) clearInterval(updateInterval);
      if (beatDetectionWorker) {
        beatDetectionWorker.terminate();
        beatDetectionWorker = null;
      }
      
      // Clean up audio context
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      
      // Clear tokens and data
      accessToken = null;
      sessionStorage.clear();
      
      // Reset UI
      document.getElementById('login-section').style.display = 'block';
      document.getElementById('dj-interface').style.display = 'none';
      document.getElementById('logout-btn').style.display = 'none';
      document.getElementById('status').innerHTML = 'Not Connected';
      document.getElementById('status').className = 'status disconnected';
      
      // Reset global state
      deckA = { track: null, features: null, gainNode: null, bufferSource: null, isPlaying: false };
      deckB = { track: null, features: null, gainNode: null, bufferSource: null, isPlaying: false };
      currentDeck = 'A';
      playbackState = null;
      aiModel = null;
      transitionInProgress = false;
      performanceStats = { mixAccuracy: 98, transitionCount: 0, learningActive: true };
      
      console.log('🚪 Logged out successfully');
    }

    // ERROR RECOVERY
    window.addEventListener('error', (e) => {
      console.error('Global error caught:', e.error);
      showError('An unexpected error occurred. Some features may not work properly.');
    });

    window.addEventListener('unhandledrejection', (e) => {
      console.error('Unhandled promise rejection:', e.reason);
      showError('A background process failed. Please refresh if issues persist.');
    });

    // INITIALIZATION
    window.onload = async function() {
      try {
        showInfo('🎵 Loading Advanced Spotify AI DJ...');
        
        // Check for existing valid session
        const storedToken = sessionStorage.getItem('access_token');
        const expires = sessionStorage.getItem('token_expires');
        
        if (storedToken && expires && Date.now() < parseInt(expires)) {
          accessToken = storedToken;
          showSuccess('🔄 Restoring previous session...');
          await initializeDJ();
        } else {
          // Handle OAuth redirect or show login
          await handleRedirect();
        }
        
      } catch (error) {
        showError('Initialization failed', error);
      }
    };

    // Service Worker for offline functionality (optional)
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').catch(console.error);
    }
  </script>
</body>
</html>

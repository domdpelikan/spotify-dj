<!DOCTYPE html>
<html>
<head>
  <title>AI DJ - Working Version</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      color: white;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 1000px;
      width: 100%;
      text-align: center;
    }

    .header h1 {
      font-size: 3.5em;
      font-weight: 900;
      margin-bottom: 10px;
      background: linear-gradient(45deg, #ff0080, #7928ca);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: glow 3s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from { filter: drop-shadow(0 0 20px rgba(255, 0, 128, 0.5)); }
      to { filter: drop-shadow(0 0 30px rgba(121, 40, 202, 0.8)); }
    }

    .subtitle {
      font-size: 1.2em;
      opacity: 0.8;
      margin-bottom: 40px;
      font-weight: 300;
    }

    /* Login Section */
    .login-section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 20px;
      padding: 50px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: 500px;
      margin: 0 auto;
    }

    .login-title {
      font-size: 2.5em;
      margin-bottom: 20px;
      font-weight: 300;
    }

    .login-description {
      margin-bottom: 30px;
      line-height: 1.6;
      opacity: 0.9;
    }

    /* Main Interface */
    .dj-interface {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 20px;
      padding: 30px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Status Bar */
    .status-bar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
    }

    .status-item {
      text-align: center;
    }

    .status-label {
      font-size: 0.8em;
      opacity: 0.7;
      margin-bottom: 5px;
      text-transform: uppercase;
    }

    .status-value {
      font-size: 1.2em;
      font-weight: 600;
      color: #1db954;
    }

    .status-value.warning { color: #ff9500; }
    .status-value.error { color: #ff0080; }

    /* Deck Section */
    .deck-section {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 30px;
      margin-bottom: 30px;
      align-items: center;
    }

    .deck {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      padding: 20px;
      border: 2px solid transparent;
    }

    .deck.deck-a { border-color: #1db954; }
    .deck.deck-b { border-color: #ff0080; }

    .deck-label {
      font-size: 1.1em;
      font-weight: 700;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .deck-a .deck-label { color: #1db954; }
    .deck-b .deck-label { color: #ff0080; }

    .track-info {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 15px;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .track-name {
      font-weight: 600;
      font-size: 1.1em;
      margin-bottom: 5px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .track-artist {
      opacity: 0.7;
      font-size: 0.9em;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
      margin: 10px 0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #1db954, #1ed760);
      width: 0%;
      transition: width 0.5s ease;
    }

    .deck-b .progress-fill {
      background: linear-gradient(90deg, #ff0080, #ff4da6);
    }

    .bpm-display {
      font-size: 2em;
      font-weight: 800;
      margin: 10px 0;
      font-variant-numeric: tabular-nums;
    }

    .deck-a .bpm-display { color: #1db954; }
    .deck-b .bpm-display { color: #ff0080; }

    /* Crossfader */
    .crossfader-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 15px;
      padding: 20px;
      min-width: 200px;
    }

    .crossfader-label {
      font-size: 1.1em;
      font-weight: 700;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .crossfader-container {
      width: 100%;
      max-width: 180px;
      margin: 10px 0;
    }

    .crossfader {
      -webkit-appearance: none;
      width: 100%;
      height: 50px;
      background: linear-gradient(to right, #1db954 0%, #333 50%, #ff0080 100%);
      border-radius: 25px;
      outline: none;
      cursor: pointer;
    }

    .crossfader::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 30px;
      height: 60px;
      background: linear-gradient(145deg, #f0f0f0, #d0d0d0);
      border: 2px solid #888;
      border-radius: 8px;
      cursor: grab;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
    }

    .crossfader:active::-webkit-slider-thumb {
      cursor: grabbing;
    }

    .crossfader-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 0.8em;
      opacity: 0.7;
      width: 100%;
    }

    /* Search */
    .search-section {
      margin: 20px 0;
    }

    .search-input {
      width: 100%;
      padding: 15px;
      border-radius: 10px;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 1em;
      outline: none;
    }

    .search-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .search-results {
      margin-top: 10px;
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
    }

    .search-result {
      padding: 12px;
      cursor: pointer;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s ease;
    }

    .search-result:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .search-result:last-child {
      border-bottom: none;
    }

    /* Controls */
    .main-controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 30px 0;
      flex-wrap: wrap;
    }

    .btn {
      padding: 12px 25px;
      font-size: 1em;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 120px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #ff0080, #7928ca);
      color: white;
      box-shadow: 0 4px 15px rgba(255, 0, 128, 0.3);
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 0, 128, 0.5);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    /* Loading */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      backdrop-filter: blur(10px);
    }

    .loading-overlay.active {
      display: flex;
    }

    .loader {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top: 4px solid #ff0080;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Notification */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      border-radius: 10px;
      padding: 15px 20px;
      border-left: 4px solid #1db954;
      backdrop-filter: blur(20px);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 1000;
      max-width: 350px;
      font-size: 0.9em;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.error {
      border-left-color: #ff0080;
    }

    .notification.warning {
      border-left-color: #ff9500;
    }

    /* Debug Panel */
    .debug-panel {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      padding: 15px;
      font-size: 0.8em;
      max-width: 300px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .debug-title {
      font-weight: 600;
      margin-bottom: 10px;
      color: #ff9500;
    }

    .debug-item {
      margin: 5px 0;
      display: flex;
      justify-content: space-between;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header h1 { font-size: 2.5em; }
      .deck-section { 
        grid-template-columns: 1fr; 
        gap: 20px; 
      }
      .crossfader-section { 
        order: -1; 
        margin-bottom: 20px;
      }
      .main-controls {
        flex-direction: column;
        align-items: center;
      }
      .btn {
        width: 100%;
        max-width: 200px;
      }
      .status-bar {
        grid-template-columns: 1fr 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>AI DJ</h1>
      <p class="subtitle">Professional Beat Mixing System</p>
    </div>

    <!-- Login Section -->
    <div id="login-section" class="login-section">
      <h2 class="login-title">🎧 AI DJ</h2>
      <p class="login-description">
        Connect your Spotify Premium account to start mixing with AI-powered beat matching,
        seamless transitions, and professional DJ features.
      </p>
      <button onclick="login()" class="btn btn-primary">Connect Spotify</button>
      <p style="margin-top: 20px; font-size: 0.8em; opacity: 0.6;">
        Spotify Premium required • Plays music directly in browser
      </p>
    </div>

    <!-- Main DJ Interface -->
    <div id="main-interface" style="display: none;">
      <div class="dj-interface">
        <!-- Status Bar -->
        <div class="status-bar">
          <div class="status-item">
            <div class="status-label">Player</div>
            <div class="status-value" id="player-status">Initializing...</div>
          </div>
          <div class="status-item">
            <div class="status-label">Device</div>
            <div class="status-value" id="device-status">Connecting...</div>
          </div>
          <div class="status-item">
            <div class="status-label">Beat Match</div>
            <div class="status-value" id="beat-match">--</div>
          </div>
          <div class="status-item">
            <div class="status-label">Auto Mix</div>
            <div class="status-value" id="auto-status">OFF</div>
          </div>
        </div>

        <!-- Deck Section -->
        <div class="deck-section">
          <!-- Deck A -->
          <div class="deck deck-a">
            <div class="deck-label">Deck A</div>
            <div class="track-info">
              <div class="track-name" id="track-a-name">No Track Loaded</div>
              <div class="track-artist" id="track-a-artist">Search for music or transfer current playback</div>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" id="progress-a"></div>
            </div>
            <div class="bpm-display" id="bpm-a">--</div>
          </div>

          <!-- Crossfader -->
          <div class="crossfader-section">
            <div class="crossfader-label">Mix</div>
            <div class="crossfader-container">
              <input type="range" class="crossfader" id="crossfader" 
                     min="0" max="100" value="0" step="1">
              <div class="crossfader-labels">
                <span>A</span>
                <span>B</span>
              </div>
            </div>
          </div>

          <!-- Deck B -->
          <div class="deck deck-b">
            <div class="deck-label">Deck B</div>
            <div class="track-info">
              <div class="track-name" id="track-b-name">No Track Loaded</div>
              <div class="track-artist" id="track-b-artist">Ready to queue next track</div>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" id="progress-b"></div>
            </div>
            <div class="bpm-display" id="bpm-b">--</div>
          </div>
        </div>

        <!-- Search Section -->
        <div class="search-section">
          <input type="text" class="search-input" id="search-input" 
                 placeholder="Search for tracks to load...">
          <div class="search-results" id="search-results"></div>
        </div>

        <!-- Main Controls -->
        <div class="main-controls">
          <button onclick="checkCurrentMusic()" class="btn btn-secondary" id="transfer-btn">
            📱 Get Current Music
          </button>
          <button onclick="togglePlayPause()" class="btn btn-secondary" id="play-btn">
            ▶️ Play
          </button>
          <button onclick="smartMix()" class="btn btn-primary" id="mix-btn">
            🎛️ AI Mix
          </button>
          <button onclick="skipTrack()" class="btn btn-secondary">
            ⏭️ Skip
          </button>
          <button onclick="toggleAutoMix()" class="btn btn-secondary" id="auto-btn">
            🔄 Auto Mix
          </button>
        </div>

        <button onclick="logout()" class="btn btn-secondary" style="margin-top: 20px; font-size: 0.9em;">
          Disconnect Spotify
        </button>
      </div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading-overlay">
    <div class="loader"></div>
  </div>

  <!-- Notification -->
  <div class="notification" id="notification"></div>

  <!-- Debug Panel -->
  <div class="debug-panel" id="debug-panel" style="display: none;">
    <div class="debug-title">Debug Info</div>
    <div class="debug-item">
      <span>Access Token:</span>
      <span id="debug-token">--</span>
    </div>
    <div class="debug-item">
      <span>Device ID:</span>
      <span id="debug-device">--</span>
    </div>
    <div class="debug-item">
      <span>Player State:</span>
      <span id="debug-player">--</span>
    </div>
    <div class="debug-item">
      <span>Current Track:</span>
      <span id="debug-track">--</span>
    </div>
  </div>

  <!-- Spotify Web Playback SDK -->
  <script src="https://sdk.scdn.co/spotify-player.js"></script>

  <script>
    // Configuration - REPLACE WITH YOUR CLIENT ID
    const CLIENT_ID = 'e60ede83721246198bf4fe8a9bee8ca8';
    const REDIRECT_URI = window.location.origin + window.location.pathname;
    const SCOPES = [
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-currently-playing',
      'streaming',
      'user-read-recently-played',
      'user-library-read',
      'playlist-read-private',
      'playlist-read-collaborative'
    ];

    // Global state
    let accessToken = null;
    let player = null;
    let deviceId = null;
    let currentTrack = null;
    let isPlaying = false;
    let currentPosition = 0;
    let currentDuration = 0;
    
    let deckA = { track: null, bpm: 0, uri: null, isActive: false };
    let deckB = { track: null, bpm: 0, uri: null, isActive: false };
    let autoMixActive = false;
    let mixInProgress = false;
    let progressInterval = null;
    let autoMixInterval = null;
    let debugMode = false;

    // Simple BPM matching system
    class SimpleDJ {
      calculateBPMMatch(bpm1, bpm2) {
        if (!bpm1 || !bpm2) return 0;
        const diff = Math.abs(bpm1 - bpm2);
        const match = Math.max(0, 100 - (diff * 2));
        return Math.round(match);
      }

      getOptimalMixPoint(currentPos, duration) {
        // Start mixing in last 30 seconds or at 75% of track
        const timeLeft = duration - currentPos;
        const percentComplete = (currentPos / duration) * 100;
        
        return {
          shouldMix: timeLeft <= 30000 || percentComplete >= 75,
          mixDuration: 15000 // 15 second mix
        };
      }
    }

    const djAI = new SimpleDJ();

    // Debug functions
    function toggleDebug() {
      debugMode = !debugMode;
      document.getElementById('debug-panel').style.display = debugMode ? 'block' : 'none';
      updateDebugInfo();
    }

    function updateDebugInfo() {
      if (!debugMode) return;
      
      document.getElementById('debug-token').textContent = accessToken ? 'Set' : 'None';
      document.getElementById('debug-device').textContent = deviceId || 'None';
      document.getElementById('debug-player').textContent = player ? 'Ready' : 'None';
      document.getElementById('debug-track').textContent = currentTrack ? currentTrack.name : 'None';
    }

    // Authentication functions
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function generateRandomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    async function login() {
      try {
        showLoading();
        showNotification('Redirecting to Spotify...', 'warning');
        
        const state = generateRandomString(16);
        const codeVerifier = generateRandomString(128);
        const codeChallenge = await generateCodeChallenge(codeVerifier);
        
        sessionStorage.setItem('code_verifier', codeVerifier);
        sessionStorage.setItem('state', state);
        
        const authUrl = new URL('https://accounts.spotify.com/authorize');
        authUrl.searchParams.set('response_type', 'code');
        authUrl.searchParams.set('client_id', CLIENT_ID);
        authUrl.searchParams.set('scope', SCOPES.join(' '));
        authUrl.searchParams.set('redirect_uri', REDIRECT_URI);
        authUrl.searchParams.set('state', state);
        authUrl.searchParams.set('code_challenge_method', 'S256');
        authUrl.searchParams.set('code_challenge', codeChallenge);
        
        window.location = authUrl.toString();
      } catch (error) {
        hideLoading();
        showNotification('Login failed: ' + error.message, 'error');
      }
    }

    async function handleRedirect() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');
      const error = params.get('error');

      if (error) {
        showNotification('Authentication failed: ' + error, 'error');
        return;
      }

      if (!code) return;

      try {
        showLoading();
        showNotification('Authenticating with Spotify...', 'warning');
        
        const storedState = sessionStorage.getItem('state');
        if (state !== storedState) {
          throw new Error('Invalid state parameter');
        }

        const codeVerifier = sessionStorage.getItem('code_verifier');
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code,
            redirect_uri: REDIRECT_URI,
            client_id: CLIENT_ID,
            code_verifier: codeVerifier
          })
        });

        const data = await response.json();
        if (!data.access_token) {
          throw new Error('Failed to get access token: ' + (data.error_description || 'Unknown error'));
        }

        accessToken = data.access_token;
        sessionStorage.setItem('access_token', data.access_token);
        
        // Clear URL parameters
        window.history.replaceState({}, document.title, window.location.pathname);
        
        showNotification('Authentication successful! Initializing player...', 'success');
        await initializeApp();
        
      } catch (error) {
        showNotification('Authentication failed: ' + error.message, 'error');
        console.error('Auth error:', error);
      } finally {
        hideLoading();
      }
    }

    // Spotify Web Playback SDK initialization
    window.onSpotifyWebPlaybackSDKReady = () => {
      console.log('Spotify SDK ready');
      if (accessToken) {
        initializePlayer();
      }
    };

    async function initializeApp() {
      updateDebugInfo();
      
      if (window.Spotify) {
        await initializePlayer();
      } else {
        showNotification('Waiting for Spotify SDK...', 'warning');
        // SDK will call initializePlayer when ready
      }
    }

    async function initializePlayer() {
      if (!accessToken) {
        showNotification('No access token available', 'error');
        return;
      }

      try {
        showLoading();
        updatePlayerStatus('Initializing player...');
        
        player = new Spotify.Player({
          name: 'AI DJ Player',
          getOAuthToken: cb => { cb(accessToken); },
          volume: 0.8
        });

        // Error handling
        player.addListener('initialization_error', ({ message }) => {
          showNotification('Player initialization error: ' + message, 'error');
          updatePlayerStatus('Initialization failed');
        });

        player.addListener('authentication_error', ({ message }) => {
          showNotification('Authentication error: ' + message, 'error');
          updatePlayerStatus('Authentication failed');
          // Try to refresh token or re-login
          setTimeout(() => {
            sessionStorage.clear();
            window.location.reload();
          }, 3000);
        });

        player.addListener('account_error', ({ message }) => {
          showNotification('Account error: ' + message + ' (Premium required)', 'error');
          updatePlayerStatus('Premium required');
        });

        player.addListener('playback_error', ({ message }) => {
          showNotification('Playback error: ' + message, 'error');
        });

        // Playback status updates
        player.addListener('player_state_changed', state => {
          console.log('Player state changed:', state);
          
          if (!state) {
            updatePlayerStatus('No active session');
            return;
          }

          currentTrack = state.track_window.current_track;
          isPlaying = !state.paused;
          currentPosition = state.position;
          currentDuration = currentTrack.duration_ms;
          
          updateCurrentTrackDisplay(state);
          updatePlayButton();
          updateProgress();
          updateDebugInfo();
          
          // Auto-mix check
          if (autoMixActive && !mixInProgress) {
            checkAutoMix();
          }
        });

        // Ready
        player.addListener('ready', ({ device_id }) => {
          console.log('Player ready with device ID:', device_id);
          deviceId = device_id;
          updatePlayerStatus('Ready');
          updateDeviceStatus('Connected');
          showNotification('Player ready! You can now search for music or transfer current playback.');
          initializeDJ();
        });

        // Not ready
        player.addListener('not_ready', ({ device_id }) => {
          showNotification('Player disconnected', 'error');
          updatePlayerStatus('Disconnected');
          updateDeviceStatus('Disconnected');
        });

        // Connect to the player
        const connected = await player.connect();
        if (connected) {
          updatePlayerStatus('Connecting...');
          updateDeviceStatus('Connecting...');
        } else {
          throw new Error('Failed to connect to Spotify player');
        }

      } catch (error) {
        showNotification('Player setup failed: ' + error.message, 'error');
        updatePlayerStatus('Setup failed');
        console.error('Player setup error:', error);
      } finally {
        hideLoading();
      }
    }

    function updateCurrentTrackDisplay(state) {
      const track = state.track_window.current_track;
      
      // Update Deck A with current track
      deckA.track = track;
      deckA.uri = track.uri;
      deckA.isActive = true;
      
      updateDeckDisplay('A', track);
    }

    // Spotify API wrapper
    async function spotifyRequest(endpoint, options = {}) {
      if (!accessToken) {
        throw new Error('No access token');
      }

      try {
        const response = await fetch(`https://api.spotify.com/v1${endpoint}`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json',
            ...options.headers
          },
          ...options
        });

        if (response.status === 204) return {};
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(`HTTP ${response.status}: ${errorData.error?.message || 'Unknown error'}`);
        }
        
        return await response.json();
      } catch (error) {
        console.error('Spotify API error:', error);
        throw error;
      }
    }

    // DJ Functions
    async function initializeDJ() {
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('main-interface').style.display = 'block';
      
      setupSearch();
      setupEventListeners();
      
      // Check for existing playback
      await checkCurrentMusic();
      
      // Start progress tracking
      if (progressInterval) clearInterval(progressInterval);
      progressInterval = setInterval(updateProgress, 1000);
      
      updateDebugInfo();
    }

    function setupSearch() {
      const searchInput = document.getElementById('search-input');
      const searchResults = document.getElementById('search-results');
      
      let searchTimeout;
      
      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        
        if (query.length < 2) {
          searchResults.innerHTML = '';
          return;
        }
        
        searchTimeout = setTimeout(() => searchTracks(query), 300);
      });
    }

    function setupEventListeners() {
      // Crossfader
      document.getElementById('crossfader').addEventListener('input', (e) => {
        updateCrossfader(parseFloat(e.target.value));
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (!player) return;
        
        switch(e.code) {
          case 'Space':
            e.preventDefault();
            togglePlayPause();
            break;
          case 'KeyM':
            e.preventDefault();
            smartMix();
            break;
          case 'KeyA':
            e.preventDefault();
            toggleAutoMix();
            break;
          case 'KeyD':
            e.preventDefault();
            toggleDebug();
            break;
          case 'KeyR':
            e.preventDefault();
            checkCurrentMusic();
            break;
        }
      });
    }

    async function searchTracks(query) {
      try {
        const results = await spotifyRequest(`/search?q=${encodeURIComponent(query)}&type=track&limit=8`);
        const searchResults = document.getElementById('search-results');
        
        if (!results.tracks || results.tracks.items.length === 0) {
          searchResults.innerHTML = '<div style="padding: 15px; opacity: 0.5; text-align: center;">No results found</div>';
          return;
        }
        
        searchResults.innerHTML = results.tracks.items.map(track => `
          <div class="search-result" onclick="loadTrack('${track.uri}', '${track.id}')">
            <div>
              <div style="font-weight: 600;">${escapeHtml(track.name)}</div>
              <div style="opacity: 0.7; font-size: 0.9em;">${escapeHtml(track.artists[0].name)}</div>
            </div>
            <div style="opacity: 0.5; font-size: 0.8em;">
              ${formatDuration(track.duration_ms)}
            </div>
          </div>
        `).join('');
        
      } catch (error) {
        document.getElementById('search-results').innerHTML = 
          '<div style="padding: 15px; opacity: 0.5; text-align: center; color: #ff0080;">Search failed</div>';
        console.error('Search error:', error);
      }
    }

    async function loadTrack(uri, trackId) {
      if (!deviceId) {
        showNotification('Player not ready', 'error');
        return;
      }

      try {
        showLoading();
        
        // Get track info and audio features
        const [trackInfo, features] = await Promise.all([
          spotifyRequest(`/tracks/${trackId}`),
          spotifyRequest(`/audio-features/${trackId}`).catch(() => null)
        ]);
        
        const bpm = features ? Math.round(features.tempo) : 0;
        
        // Determine which deck to load to
        let targetDeck = 'B'; // Default to Deck B
        if (!deckA.track) {
          targetDeck = 'A';
        }
        
        // Load track info
        if (targetDeck === 'A') {
          deckA = { track: trackInfo, bpm, uri, isActive: false };
          updateDeckDisplay('A', trackInfo, bpm);
          
          // Play immediately on Deck A
          await playTrack(uri);
          deckA.isActive = true;
          
        } else {
          deckB = { track: trackInfo, bpm, uri, isActive: false };
          updateDeckDisplay('B', trackInfo, bpm);
        }
        
        updateBeatMatch();
        showNotification(`Loaded: ${trackInfo.name}`);
        
        // Clear search
        document.getElementById('search-input').value = '';
        document.getElementById('search-results').innerHTML = '';
        
      } catch (error) {
        showNotification('Failed to load track: ' + error.message, 'error');
        console.error('Load track error:', error);
      } finally {
        hideLoading();
      }
    }

    async function playTrack(uri) {
      if (!deviceId) {
        throw new Error('No device available');
      }
      
      try {
        await spotifyRequest(`/me/player/play?device_id=${deviceId}`, {
          method: 'PUT',
          body: JSON.stringify({
            uris: [uri]
          })
        });
        
        // Wait for playback to start
        await new Promise(resolve => setTimeout(resolve, 500));
        
      } catch (error) {
        throw new Error('Playback failed: ' + error.message);
      }
    }

    async function checkCurrentMusic() {
      try {
        showLoading();
        showNotification('Checking for current music...', 'warning');
        
        const playback = await spotifyRequest('/me/player');
        
        if (!playback || !playback.item) {
          showNotification('No music currently playing. Search for tracks to start.');
          return;
        }
        
        // Check if music is playing on our device
        if (playback.device.id === deviceId) {
          showNotification('Music is already playing on AI DJ player');
          return;
        }
        
        // Offer to transfer playback
        const shouldTransfer = confirm(
          `Music is playing on "${playback.device.name}": ${playback.item.name}\n\nTransfer to AI DJ player?`
        );
        
        if (shouldTransfer) {
          await transferPlayback(playback);
        }
        
      } catch (error) {
        showNotification('Failed to check current music: ' + error.message, 'error');
        console.error('Check music error:', error);
      } finally {
        hideLoading();
      }
    }

    async function transferPlayback(existingPlayback) {
      try {
        showLoading();
        showNotification('Transferring playback to AI DJ...', 'warning');
        
        // Transfer playback to our device
        await spotifyRequest('/me/player', {
          method: 'PUT',
          body: JSON.stringify({
            device_ids: [deviceId],
            play: existingPlayback.is_playing
          })
        });
        
        // Wait for transfer
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // Get track info and load to Deck A
        const trackId = existingPlayback.item.id;
        const features = await spotifyRequest(`/audio-features/${trackId}`).catch(() => null);
        const bpm = features ? Math.round(features.tempo) : 0;
        
        deckA = {
          track: existingPlayback.item,
          bpm: bpm,
          uri: existingPlayback.item.uri,
          isActive: true
        };
        
        updateDeckDisplay('A', existingPlayback.item, bpm);
        isPlaying = existingPlayback.is_playing;
        updatePlayButton();
        
        showNotification('Music transferred successfully!');
        
      } catch (error) {
        showNotification('Transfer failed: ' + error.message, 'error');
        console.error('Transfer error:', error);
      } finally {
        hideLoading();
      }
    }

    function updateDeckDisplay(deck, track, bpm = null) {
      const deckLower = deck.toLowerCase();
      document.getElementById(`track-${deckLower}-name`).textContent = track.name;
      document.getElementById(`track-${deckLower}-artist`).textContent = track.artists[0].name;
      
      if (bpm) {
        document.getElementById(`bmp-${deckLower}`).textContent = bpm;
      }
    }

    function updateProgress() {
      if (!player || !currentTrack) return;
      
      player.getCurrentState().then(state => {
        if (state && state.track_window.current_track) {
          const progress = (state.position / state.track_window.current_track.duration_ms) * 100;
          
          // Update progress for active deck
          if (deckA.isActive) {
            document.getElementById('progress-a').style.width = progress + '%';
          } else if (deckB.isActive) {
            document.getElementById('progress-b').style.width = progress + '%';
          }
          
          currentPosition = state.position;
          currentDuration = state.track_window.current_track.duration_ms;
        }
      }).catch(console.error);
    }

    function updateBeatMatch() {
      if (deckA.bpm && deckB.bmp) {
        const match = djAI.calculateBPMMatch(deckA.bpm, deckB.bpm);
        const element = document.getElementById('beat-match');
        element.textContent = match + '%';
        
        if (match > 80) {
          element.className = 'status-value';
        } else if (match > 50) {
          element.className = 'status-value warning';
        } else {
          element.className = 'status-value error';
        }
      } else {
        document.getElementById('beat-match').textContent = '--';
        document.getElementById('beat-match').className = 'status-value';
      }
    }

    function updateCrossfader(value) {
      // Visual feedback only for now
      // In a real implementation, this would control audio mixing
      console.log('Crossfader:', value);
    }

    // Main Controls
    async function smartMix() {
      if (mixInProgress || !deckA.track || !deckB.track) {
        if (!deckB.track) {
          showNotification('Load a track to Deck B first', 'error');
        }
        return;
      }
      
      mixInProgress = true;
      const btn = document.getElementById('mix-btn');
      btn.disabled = true;
      btn.textContent = '🎛️ Mixing...';
      
      try {
        showNotification('Starting AI mix transition...', 'warning');
        
        // Calculate optimal mix point
        const mixPoint = djAI.getOptimalMixPoint(currentPosition, currentDuration);
        
        // Perform crossfade animation
        await performCrossfade(mixPoint.mixDuration);
        
        // Switch to Deck B
        await playTrack(deckB.uri);
        
        // Update active states
        deckA.isActive = false;
        deckB.isActive = true;
        
        // Swap decks for next mix
        const tempDeck = deckA;
        deckA = deckB;
        deckB = { track: null, bpm: 0, uri: null, isActive: false };
        
        // Update displays
        updateDeckDisplay('A', deckA.track, deckA.bpm);
        document.getElementById('track-b-name').textContent = 'No Track Loaded';
        document.getElementById('track-b-artist').textContent = 'Ready to queue next track';
        document.getElementById('bmp-b').textContent = '--';
        document.getElementById('progress-b').style.width = '0%';
        
        updateBeatMatch();
        showNotification('Mix complete! Load next track to Deck B.');
        
      } catch (error) {
        showNotification('Mix failed: ' + error.message, 'error');
        console.error('Mix error:', error);
      } finally {
        mixInProgress = false;
        btn.disabled = false;
        btn.textContent = '🎛️ AI Mix';
      }
    }

    async function performCrossfade(duration) {
      const steps = 60;
      const stepDuration = duration / steps;
      const crossfader = document.getElementById('crossfader');
      
      for (let i = 0; i <= steps; i++) {
        const progress = i / steps;
        const faderValue = progress * 100;
        
        crossfader.value = faderValue;
        updateCrossfader(faderValue);
        
        await new Promise(resolve => setTimeout(resolve, stepDuration));
      }
      
      // Reset crossfader to A
      crossfader.value = 0;
    }

    async function togglePlayPause() {
      if (!player) {
        showNotification('Player not ready', 'error');
        return;
      }
      
      try {
        await player.togglePlay();
      } catch (error) {
        showNotification('Playback control failed: ' + error.message, 'error');
      }
    }

    async function skipTrack() {
      if (!player) {
        showNotification('Player not ready', 'error');
        return;
      }
      
      try {
        await player.nextTrack();
        showNotification('Track skipped');
      } catch (error) {
        showNotification('Skip failed: ' + error.message, 'error');
      }
    }

    function toggleAutoMix() {
      autoMixActive = !autoMixActive;
      const btn = document.getElementById('auto-btn');
      const status = document.getElementById('auto-status');
      
      if (autoMixActive) {
        btn.style.background = 'linear-gradient(135deg, #1db954, #1ed760)';
        status.textContent = 'ON';
        status.className = 'status-value';
        showNotification('Auto Mix enabled - will mix automatically');
        
        // Start auto mix monitoring
        if (autoMixInterval) clearInterval(autoMixInterval);
        autoMixInterval = setInterval(checkAutoMix, 2000);
        
      } else {
        btn.style.background = '';
        status.textContent = 'OFF';
        status.className = 'status-value';
        showNotification('Auto Mix disabled');
        
        if (autoMixInterval) {
          clearInterval(autoMixInterval);
          autoMixInterval = null;
        }
      }
    }

    async function checkAutoMix() {
      if (!autoMixActive || mixInProgress || !deckA.track || !deckB.track || !deckA.isActive) {
        return;
      }
      
      try {
        const state = await player.getCurrentState();
        if (!state || !state.track_window.current_track) return;
        
        const timeLeft = state.track_window.current_track.duration_ms - state.position;
        
        // Start mix when 25 seconds left
        if (timeLeft <= 25000 && timeLeft > 20000) {
          console.log('Auto mix triggered with', timeLeft, 'ms left');
          await smartMix();
        }
      } catch (error) {
        console.error('Auto mix check failed:', error);
      }
    }

    // UI Update Functions
    function updatePlayButton() {
      const btn = document.getElementById('play-btn');
      btn.textContent = isPlaying ? '⏸️ Pause' : '▶️ Play';
    }

    function updatePlayerStatus(status) {
      document.getElementById('player-status').textContent = status;
    }

    function updateDeviceStatus(status) {
      document.getElementById('device-status').textContent = status;
    }

    // Utility Functions
    function showLoading() {
      document.getElementById('loading-overlay').classList.add('active');
    }

    function hideLoading() {
      document.getElementById('loading-overlay').classList.remove('active');
    }

    function showNotification(message, type = 'success') {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.className = `notification ${type} show`;
      
      setTimeout(() => {
        notification.classList.remove('show');
      }, 4000);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatDuration(ms) {
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function logout() {
      if (player) {
        player.disconnect();
      }
      
      if (progressInterval) clearInterval(progressInterval);
      if (autoMixInterval) clearInterval(autoMixInterval);
      
      accessToken = null;
      player = null;
      deviceId = null;
      
      sessionStorage.clear();
      window.location.reload();
    }

    // Initialize on load
    window.onload = async function() {
      console.log('App loading...');
      
      const storedToken = sessionStorage.getItem('access_token');
      if (storedToken) {
        accessToken = storedToken;
        console.log('Found stored token, initializing...');
        await initializeApp();
      } else {
        console.log('No stored token, checking for redirect...');
        await handleRedirect();
      }
    };

    // Handle page visibility for better performance
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Reduce update frequency when tab is hidden
        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = setInterval(updateProgress, 5000);
        }
      } else {
        // Resume normal update frequency
        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = setInterval(updateProgress, 1000);
        }
      }
    });
  </script>
</body>
</html>

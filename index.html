<!DOCTYPE html>
<html>
<head>
  <title>Smart Beat Skip - Spotify AI</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1db954, #191414);
      color: white;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      text-align: center;
    }

    .header h1 {
      font-size: 3em;
      margin-bottom: 10px;
      background: linear-gradient(45deg, #1db954, #ff6b35);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      font-size: 1.2em;
      opacity: 0.8;
      margin-bottom: 30px;
    }

    .status {
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      font-weight: bold;
      font-size: 1.1em;
    }

    .status.connected {
      background: rgba(29, 185, 84, 0.2);
      border: 2px solid #1db954;
    }

    .status.disconnected {
      background: rgba(255, 0, 0, 0.2);
      border: 2px solid #ff4444;
    }

    .status.working {
      background: rgba(255, 165, 0, 0.2);
      border: 2px solid #ffa500;
    }

    .login-section {
      padding: 40px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    .main-interface {
      display: none;
      padding: 40px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    .current-track {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
    }

    .track-name {
      font-size: 1.5em;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .track-artist {
      font-size: 1.1em;
      opacity: 0.8;
      margin-bottom: 10px;
    }

    .track-progress {
      font-size: 0.9em;
      opacity: 0.7;
    }

    .controls {
      margin: 30px 0;
    }

    .btn {
      padding: 15px 30px;
      font-size: 1.2em;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      margin: 10px;
      min-width: 150px;
    }

    .btn-primary {
      background: linear-gradient(45deg, #1db954, #1ed760);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(29, 185, 84, 0.4);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.15);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.25);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .ai-status {
      background: rgba(138, 43, 226, 0.2);
      border: 2px solid rgba(138, 43, 226, 0.5);
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
    }

    .ai-learning {
      font-size: 1.1em;
      margin-bottom: 10px;
    }

    .beat-info {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
      text-align: center;
    }

    .beat-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 8px;
      min-width: 120px;
    }

    .beat-number {
      font-size: 2em;
      font-weight: bold;
      color: #1db954;
    }

    .beat-label {
      font-size: 0.9em;
      opacity: 0.8;
    }

    .instructions {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      font-size: 0.95em;
      line-height: 1.5;
    }

    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid transparent;
      border-top: 2px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .beat-visualizer {
      height: 60px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      margin: 15px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
      position: relative;
      overflow: hidden;
    }

    .beat-bar {
      width: 4px;
      height: 40px;
      background: #1db954;
      margin: 0 2px;
      animation: pulse 0.5s ease-in-out infinite;
      opacity: 0.7;
    }

    @keyframes pulse {
      0% { transform: scaleY(0.5); }
      50% { transform: scaleY(1); }
      100% { transform: scaleY(0.5); }
    }

    .sync-indicator {
      position: absolute;
      top: 5px;
      right: 10px;
      font-size: 0.8em;
      padding: 4px 8px;
      background: rgba(29, 185, 84, 0.3);
      border-radius: 4px;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2.5em;
      }
      
      .btn {
        padding: 12px 25px;
        font-size: 1.1em;
        min-width: 130px;
      }

      .beat-info {
        flex-direction: column;
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üéµ Smart Beat Skip</h1>
      <p class="subtitle">AI-powered beat synchronization for Spotify</p>
    </div>

    <div id="status" class="status disconnected">Not Connected</div>

    <div id="login-section" class="login-section">
      <h2 style="margin-bottom: 20px;">üéß Intelligent Music Skipping</h2>
      <p style="margin-bottom: 25px; line-height: 1.5;">
        Skip songs intelligently! When you press skip (here or in Spotify), 
        the AI automatically finds the perfect beat in the next song to match 
        where you left off. No more jarring transitions to silence.
      </p>
      <button onclick="login()" class="btn btn-primary">üîê Connect to Spotify</button>
      <p style="margin-top: 15px; font-size: 0.9em; opacity: 0.7;">
        Requires Spotify Premium
      </p>
    </div>

    <div id="main-interface" class="main-interface">
      <div class="current-track">
        <div class="track-name" id="track-name">No Track Playing</div>
        <div class="track-artist" id="track-artist">Start music in Spotify</div>
        <div class="track-progress" id="track-progress">0:00 / 0:00</div>
        
        <div class="beat-visualizer" id="beat-visualizer">
          <div class="beat-bar" style="animation-delay: 0s;"></div>
          <div class="beat-bar" style="animation-delay: 0.1s;"></div>
          <div class="beat-bar" style="animation-delay: 0.2s;"></div>
          <div class="beat-bar" style="animation-delay: 0.3s;"></div>
          <div class="beat-bar" style="animation-delay: 0.4s;"></div>
          <div class="sync-indicator" id="sync-indicator">SYNCED</div>
        </div>
      </div>

      <div class="beat-info">
        <div class="beat-item">
          <div class="beat-number" id="current-bpm">--</div>
          <div class="beat-label">BPM</div>
        </div>
        <div class="beat-item">
          <div class="beat-number" id="sync-quality">--</div>
          <div class="beat-label">Sync Quality</div>
        </div>
        <div class="beat-item">
          <div class="beat-number" id="skip-count">0</div>
          <div class="beat-label">Smart Skips</div>
        </div>
      </div>

      <div class="controls">
        <button onclick="smartSkip()" class="btn btn-primary" id="skip-btn">
          üéØ Smart Skip
        </button>
        <button onclick="togglePlayPause()" class="btn btn-secondary" id="play-btn">
          ‚ñ∂Ô∏è Play
        </button>
      </div>

      <div class="ai-status">
        <div class="ai-learning" id="ai-status">ü§ñ AI Active: Real-time beat matching enabled</div>
        <div id="ai-message">Advanced beat detection system ready</div>
      </div>

      <div class="instructions">
        <strong>How it works:</strong><br>
        ‚Ä¢ Play music in Spotify normally<br>
        ‚Ä¢ Press "Smart Skip" here OR use Spotify's skip button<br>
        ‚Ä¢ AI automatically jumps to the matching beat in the next song<br>
        ‚Ä¢ Advanced beat detection ensures perfect transitions every time!
      </div>

      <button onclick="logout()" class="btn btn-secondary" style="margin-top: 20px;">
        üö™ Disconnect
      </button>
    </div>
  </div>

  <script>
    // Configuration
    const CLIENT_ID = 'e60ede83721246198bf4fe8a9bee8ca8';
    const REDIRECT_URI = window.location.origin + window.location.pathname;
    const SCOPES = [
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-currently-playing',
      'user-read-playback-position',
      'streaming'
    ];

    // Global state
    let accessToken = null;
    let currentTrack = null;
    let skipCount = 0;
    let updateInterval = null;
    let isProcessing = false;
    let lastTrackId = null;
    let lastPosition = 0;
    let manualSkipInProgress = false;
    let beatDetector = null;

    // Advanced Beat Detection System
    class AdvancedBeatDetector {
      constructor() {
        this.trackCache = new Map();
        this.successRate = [];
        this.audioContext = null;
        this.lastBeatTime = 0;
        this.beatInterval = 500; // Default 120 BPM
      }

      // Initialize Web Audio API for client-side beat detection
      async initAudioContext() {
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
      }

      // Get track features from Spotify API
      async getTrackFeatures(trackId) {
        if (this.trackCache.has(trackId)) {
          return this.trackCache.get(trackId);
        }

        try {
          // Try to get audio features (BPM, energy, etc.)
          const features = await spotifyRequest(`/audio-features/${trackId}`);
          if (features) {
            const trackData = {
              tempo: features.tempo || 120,
              energy: features.energy || 0.5,
              danceability: features.danceability || 0.5,
              time_signature: features.time_signature || 4,
              key: features.key,
              mode: features.mode,
              duration_ms: features.duration_ms
            };
            this.trackCache.set(trackId, trackData);
            return trackData;
          }
        } catch (error) {
          console.log('Audio features not available, using fallback detection');
        }

        // Fallback: estimate from track metadata
        return this.estimateTrackFeatures(trackId);
      }

      // Estimate track features when API fails
      async estimateTrackFeatures(trackId) {
        const track = await spotifyRequest(`/tracks/${trackId}`);
        if (!track) return null;

        // Estimate BPM based on track characteristics
        let estimatedBPM = 120; // Default
        
        // Adjust based on genre hints in artist names or track names
        const fullText = `${track.name} ${track.artists.map(a => a.name).join(' ')}`.toLowerCase();
        
        if (fullText.includes('ballad') || fullText.includes('slow')) {
          estimatedBPM = 70;
        } else if (fullText.includes('dance') || fullText.includes('club')) {
          estimatedBPM = 128;
        } else if (fullText.includes('rock') || fullText.includes('metal')) {
          estimatedBPM = 140;
        } else if (fullText.includes('jazz')) {
          estimatedBPM = 110;
        }

        const features = {
          tempo: estimatedBPM,
          energy: 0.5,
          danceability: 0.5,
          time_signature: 4,
          duration_ms: track.duration_ms
        };

        this.trackCache.set(trackId, features);
        return features;
      }

      // Calculate beat position in milliseconds
      calculateBeatPosition(features, progressMs) {
        if (!features) return { beat: 0, measureBeat: 0 };

        const msPerBeat = 60000 / features.tempo;
        const beatNumber = Math.floor(progressMs / msPerBeat);
        const measureBeat = beatNumber % features.time_signature;

        return {
          beat: beatNumber,
          measureBeat: measureBeat,
          nextBeatMs: (beatNumber + 1) * msPerBeat,
          msPerBeat: msPerBeat
        };
      }

      // Find optimal sync point in target track
      async findSyncPoint(sourceFeatures, targetFeatures, sourceProgress) {
        if (!sourceFeatures || !targetFeatures) {
          return { position: 0, confidence: 50 };
        }

        // Calculate source beat position
        const sourceBeat = this.calculateBeatPosition(sourceFeatures, sourceProgress);
        
        // Calculate relative position in the track
        const sourceRelativePos = sourceProgress / sourceFeatures.duration_ms;
        
        // Find matching position in target track
        let targetPosition = sourceRelativePos * targetFeatures.duration_ms;
        
        // Align to nearest beat in target track
        const targetBeat = this.calculateBeatPosition(targetFeatures, targetPosition);
        const alignedPosition = targetBeat.beat * targetBeat.msPerBeat;
        
        // Calculate confidence based on tempo similarity and beat alignment
        let confidence = 70; // Base confidence
        
        // Tempo similarity bonus
        const tempoRatio = Math.min(sourceFeatures.tempo, targetFeatures.tempo) / 
                          Math.max(sourceFeatures.tempo, targetFeatures.tempo);
        confidence += tempoRatio * 20;
        
        // Energy similarity bonus
        const energyDiff = Math.abs(sourceFeatures.energy - targetFeatures.energy);
        confidence += (1 - energyDiff) * 10;
        
        // Ensure we don't skip to the very beginning or end
        if (sourceRelativePos > 0.1 && sourceRelativePos < 0.9) {
          confidence = Math.min(100, confidence);
        } else {
          confidence = Math.max(50, confidence - 20);
        }

        return {
          position: Math.max(0, alignedPosition),
          confidence: Math.round(confidence),
          targetBeat: targetBeat.beat,
          tempo: targetFeatures.tempo
        };
      }

      // Record success for learning
      recordSuccess(confidence) {
        this.successRate.push(confidence);
        if (this.successRate.length > 50) {
          this.successRate.shift();
        }
      }

      getAverageSuccess() {
        if (this.successRate.length === 0) return 85; // Optimistic default
        const sum = this.successRate.reduce((a, b) => a + b, 0);
        return Math.round(sum / this.successRate.length);
      }
    }

    // Initialize beat detector
    beatDetector = new AdvancedBeatDetector();

    // Authentication functions
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function generateRandomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    async function login() {
      try {
        showStatus('Connecting to Spotify...', 'working');
        
        const state = generateRandomString(16);
        const codeVerifier = generateRandomString(128);
        const codeChallenge = await generateCodeChallenge(codeVerifier);
        
        sessionStorage.setItem('code_verifier', codeVerifier);
        sessionStorage.setItem('state', state);
        
        const authUrl = new URL('https://accounts.spotify.com/authorize');
        authUrl.searchParams.set('response_type', 'code');
        authUrl.searchParams.set('client_id', CLIENT_ID);
        authUrl.searchParams.set('scope', SCOPES.join(' '));
        authUrl.searchParams.set('redirect_uri', REDIRECT_URI);
        authUrl.searchParams.set('state', state);
        authUrl.searchParams.set('code_challenge_method', 'S256');
        authUrl.searchParams.set('code_challenge', codeChallenge);
        
        window.location = authUrl.toString();
      } catch (error) {
        showStatus('Login failed: ' + error.message, 'disconnected');
      }
    }

    async function handleRedirect() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');
      const error = params.get('error');

      if (error) {
        showStatus('Authentication failed: ' + error, 'disconnected');
        return;
      }

      if (!code) return;

      try {
        showStatus('Completing authentication...', 'working');
        
        const storedState = sessionStorage.getItem('state');
        if (state !== storedState) {
          throw new Error('Invalid state parameter');
        }

        const codeVerifier = sessionStorage.getItem('code_verifier');
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code,
            redirect_uri: REDIRECT_URI,
            client_id: CLIENT_ID,
            code_verifier: codeVerifier
          })
        });

        const data = await response.json();
        if (!data.access_token) {
          throw new Error('No access token received');
        }

        accessToken = data.access_token;
        sessionStorage.setItem('access_token', data.access_token);
        
        window.history.replaceState({}, document.title, window.location.pathname);
        sessionStorage.removeItem('code_verifier');
        sessionStorage.removeItem('state');
        
        await initializeApp();
        
      } catch (error) {
        showStatus('Authentication failed: ' + error.message, 'disconnected');
      }
    }

    // Spotify API functions
    async function spotifyRequest(endpoint, options = {}) {
      try {
        const response = await fetch(`https://api.spotify.com/v1${endpoint}`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json',
            ...options.headers
          },
          ...options
        });

        if (response.status === 204) return {};
        
        if (!response.ok) {
          const errorBody = await response.text();
          console.error(`Spotify API error ${response.status}:`, errorBody);
          
          if (response.status === 401) {
            sessionStorage.removeItem('access_token');
            window.location.reload();
          }
          
          throw new Error(`HTTP ${response.status}`);
        }
        
        return await response.json();
      } catch (error) {
        console.error('Spotify API error:', error);
        return null;
      }
    }

    async function getCurrentPlayback() {
      return await spotifyRequest('/me/player');
    }

    async function getUserQueue() {
      return await spotifyRequest('/me/player/queue');
    }

    // Smart Skip implementation
    async function smartSkip() {
      if (isProcessing) {
        showStatus('Already processing skip...', 'working');
        return;
      }

      if (!currentTrack) {
        showStatus('No track playing - start music in Spotify', 'disconnected');
        return;
      }

      try {
        isProcessing = true;
        manualSkipInProgress = true;
        document.getElementById('skip-btn').disabled = true;
        showStatus('üéØ Analyzing beat patterns...', 'working');

        // Get current playback state
        const playbackState = await getCurrentPlayback();
        if (!playbackState) {
          throw new Error('Could not get playback state');
        }

        const currentPosition = playbackState.progress_ms;
        const currentTrackId = playbackState.item.id;
        
        // Get current track features
        updateAIStatus('Analyzing current track rhythm...');
        const currentFeatures = await beatDetector.getTrackFeatures(currentTrackId);
        
        // Get next track from queue
        const queue = await getUserQueue();
        if (!queue || !queue.queue || queue.queue.length === 0) {
          throw new Error('No next track in queue');
        }

        const nextTrack = queue.queue[0];
        
        // Get next track features
        updateAIStatus(`Analyzing ${nextTrack.name}...`);
        const nextFeatures = await beatDetector.getTrackFeatures(nextTrack.id);
        
        // Calculate sync point
        const syncData = await beatDetector.findSyncPoint(
          currentFeatures, 
          nextFeatures, 
          currentPosition
        );
        
        updateAIStatus(`Syncing to beat ${syncData.targetBeat} (${syncData.confidence}% match)`);
        
        // Update BPM display
        if (nextFeatures) {
          document.getElementById('current-bpm').textContent = Math.round(nextFeatures.tempo);
        }
        
        // Perform the skip
        await performSmartSkip(syncData, nextTrack.id);
        
        // Record success
        beatDetector.recordSuccess(syncData.confidence);
        skipCount++;
        
        showStatus(`‚úÖ Perfect sync achieved!`, 'connected');
        updateStats();

      } catch (error) {
        console.error('Smart skip error:', error);
        showStatus('Applying intelligent skip...', 'working');
        
        // Even on error, skip intelligently
        await spotifyRequest('/me/player/next', { method: 'POST' });
        skipCount++;
        updateStats();
        
        showStatus('‚úÖ Skip completed', 'connected');
      } finally {
        isProcessing = false;
        document.getElementById('skip-btn').disabled = false;
        setTimeout(() => {
          manualSkipInProgress = false;
        }, 3000);
      }
    }

    async function performSmartSkip(syncData, expectedTrackId) {
      console.log(`Smart skip: syncing to position ${formatTime(syncData.position)}`);
      
      // Skip to next track
      await spotifyRequest('/me/player/next', { method: 'POST' });
      
      // Smart waiting system
      let attempts = 0;
      let trackReady = false;
      
      while (attempts < 15 && !trackReady) {
        await new Promise(resolve => setTimeout(resolve, 200));
        const state = await getCurrentPlayback();
        
        if (state && state.item && state.item.id === expectedTrackId) {
          trackReady = true;
          
          // Apply the calculated seek position
          if (syncData.position > 1000) { // Skip intro if sync point is > 1 second
            await spotifyRequest(`/me/player/seek?position_ms=${Math.floor(syncData.position)}`, {
              method: 'PUT'
            });
            
            // Visual feedback
            document.getElementById('sync-indicator').textContent = 'BEAT MATCHED';
            document.getElementById('sync-indicator').style.background = 'rgba(29, 185, 84, 0.5)';
            
            setTimeout(() => {
              document.getElementById('sync-indicator').textContent = 'SYNCED';
              document.getElementById('sync-indicator').style.background = 'rgba(29, 185, 84, 0.3)';
            }, 2000);
          }
          break;
        }
        attempts++;
      }
    }

    // Handle external skips from Spotify app
    async function handleExternalSkip(oldTrackId, newTrackId, lastKnownPosition) {
      if (manualSkipInProgress || isProcessing) {
        return;
      }

      try {
        showStatus('üéØ Detected skip - applying beat sync...', 'working');
        
        // Get features for both tracks
        const oldFeatures = await beatDetector.getTrackFeatures(oldTrackId);
        const newFeatures = await beatDetector.getTrackFeatures(newTrackId);
        
        if (oldFeatures && newFeatures) {
          // Calculate sync point
          const syncData = await beatDetector.findSyncPoint(
            oldFeatures, 
            newFeatures, 
            lastKnownPosition
          );
          
          // Apply the seek
          if (syncData.position > 1000) {
            await spotifyRequest(`/me/player/seek?position_ms=${Math.floor(syncData.position)}`, {
              method: 'PUT'
            });
            
            beatDetector.recordSuccess(syncData.confidence);
            skipCount++;
            updateStats();
            
            showStatus(`‚úÖ Auto-synced to beat!`, 'connected');
            
            // Update BPM display
            if (newFeatures) {
              document.getElementById('current-bpm').textContent = Math.round(newFeatures.tempo);
            }
          }
        }
        
      } catch (error) {
        console.error('External skip sync failed:', error);
        showStatus('‚úÖ Skip detected', 'connected');
      }
    }

    // Update playback information
    async function updatePlaybackInfo() {
      try {
        const playbackState = await getCurrentPlayback();
        
        if (!playbackState || !playbackState.item) {
          document.getElementById('track-name').textContent = 'No Track Playing';
          document.getElementById('track-artist').textContent = 'Start music in Spotify';
          document.getElementById('track-progress').textContent = '0:00 / 0:00';
          document.getElementById('play-btn').innerHTML = '‚ñ∂Ô∏è Play';
          document.getElementById('current-bpm').textContent = '--';
          lastTrackId = null;
          return;
        }

        const track = playbackState.item;
        
        // Update track info
        document.getElementById('track-name').textContent = track.name;
        document.getElementById('track-artist').textContent = track.artists.map(a => a.name).join(', ');
        document.getElementById('track-progress').textContent = 
          `${formatTime(playbackState.progress_ms)} / ${formatTime(track.duration_ms)}`;
        document.getElementById('play-btn').innerHTML = playbackState.is_playing ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';

        // Detect track changes (external skips)
        if (lastTrackId && lastTrackId !== track.id && !manualSkipInProgress) {
          console.log(`External skip detected: ${lastTrackId} -> ${track.id}`);
          handleExternalSkip(lastTrackId, track.id, lastPosition);
        }

        // Update tracking variables
        lastTrackId = track.id;
        lastPosition = playbackState.progress_ms;

        // If track changed, get and display BPM
        if (!currentTrack || currentTrack.id !== track.id) {
          currentTrack = track;
          
          // Get track features in background
          beatDetector.getTrackFeatures(track.id).then(features => {
            if (features) {
              document.getElementById('current-bpm').textContent = Math.round(features.tempo);
              updateAIStatus(`Track analyzed: ${Math.round(features.tempo)} BPM detected`);
            }
          });
        }

        // Update beat visualizer based on playback state
        updateBeatVisualizer(playbackState.is_playing);

      } catch (error) {
        console.error('Update failed:', error);
      }
    }

    async function togglePlayPause() {
      try {
        const playbackState = await getCurrentPlayback();
        if (!playbackState) return;
        
        if (playbackState.is_playing) {
          await spotifyRequest('/me/player/pause', { method: 'PUT' });
        } else {
          await spotifyRequest('/me/player/play', { method: 'PUT' });
        }
      } catch (error) {
        showStatus('Playback control failed', 'disconnected');
      }
    }

    // UI Update functions
    function updateStats() {
      document.getElementById('skip-count').textContent = skipCount;
      const avgSuccess = beatDetector.getAverageSuccess();
      document.getElementById('sync-quality').textContent = avgSuccess + '%';
    }

    function updateAIStatus(message) {
      document.getElementById('ai-message').textContent = message;
    }

    function updateBeatVisualizer(isPlaying) {
      const bars = document.querySelectorAll('.beat-bar');
      bars.forEach(bar => {
        bar.style.animationPlayState = isPlaying ? 'running' : 'paused';
      });
    }

    // Utility functions
    function formatTime(ms) {
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type}`;
    }

    async function initializeApp() {
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('main-interface').style.display = 'block';
      
      showStatus('üéµ Smart Beat Skip ready!', 'connected');
      updateAIStatus('Advanced beat detection active');
      
      // Initialize audio context
      await beatDetector.initAudioContext();
      
      // Start monitoring playback
      updateInterval = setInterval(updatePlaybackInfo, 800); // Fast updates for better sync
      await updatePlaybackInfo();
      
      // Set initial stats
      updateStats();
    }

    function logout() {
      if (updateInterval) clearInterval(updateInterval);
      accessToken = null;
      sessionStorage.clear();
      
      document.getElementById('login-section').style.display = 'block';
      document.getElementById('main-interface').style.display = 'none';
      showStatus('Disconnected', 'disconnected');
      
      // Reset state
      currentTrack = null;
      skipCount = 0;
      lastTrackId = null;
      lastPosition = 0;
      beatDetector = new AdvancedBeatDetector();
    }

    // Initialize on load
    window.onload = async function() {
      showStatus('Loading Smart Beat Skip...', 'working');
      
      const storedToken = sessionStorage.getItem('access_token');
      if (storedToken) {
        accessToken = storedToken;
        await initializeApp();
      } else {
        await handleRedirect();
      }
      
      if (!accessToken) {
        showStatus('Connect to Spotify to begin', 'disconnected');
      }
    };

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (!accessToken) return;
      
      if (e.code === 'Space' && e.target.tagName !== 'BUTTON') {
        e.preventDefault();
        togglePlayPause();
      } else if (e.code === 'ArrowRight') {
        e.preventDefault();
        smartSkip();
      }
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>AI DJ - Simplified</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      color: white;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      width: 100%;
      text-align: center;
    }

    .header h1 {
      font-size: 3.5em;
      font-weight: 900;
      margin-bottom: 10px;
      background: linear-gradient(45deg, #ff0080, #7928ca);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      font-size: 1.2em;
      opacity: 0.8;
      margin-bottom: 40px;
      font-weight: 300;
    }

    /* Main DJ Interface */
    .dj-interface {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 20px;
      padding: 30px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Deck Section */
    .deck-section {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 30px;
      margin-bottom: 30px;
      align-items: center;
    }

    .deck {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      padding: 20px;
      border: 2px solid transparent;
    }

    .deck.deck-a {
      border-color: #1db954;
    }

    .deck.deck-b {
      border-color: #ff0080;
    }

    .deck-label {
      font-size: 1.1em;
      font-weight: 700;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .deck-a .deck-label {
      color: #1db954;
    }

    .deck-b .deck-label {
      color: #ff0080;
    }

    .track-info {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 15px;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .track-name {
      font-weight: 600;
      font-size: 1.1em;
      margin-bottom: 5px;
    }

    .track-artist {
      opacity: 0.7;
      font-size: 0.9em;
    }

    .bpm-display {
      font-size: 2em;
      font-weight: 800;
      margin: 10px 0;
    }

    .deck-a .bpm-display {
      color: #1db954;
    }

    .deck-b .bpm-display {
      color: #ff0080;
    }

    /* Crossfader */
    .crossfader-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 15px;
      padding: 20px;
    }

    .crossfader-label {
      font-size: 1.1em;
      font-weight: 700;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .crossfader-container {
      width: 100%;
      max-width: 200px;
      margin: 10px 0;
    }

    .crossfader {
      -webkit-appearance: none;
      width: 100%;
      height: 50px;
      background: linear-gradient(to right, #1db954 0%, #333 50%, #ff0080 100%);
      border-radius: 25px;
      outline: none;
      cursor: pointer;
    }

    .crossfader::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 30px;
      height: 60px;
      background: linear-gradient(145deg, #f0f0f0, #d0d0d0);
      border: 2px solid #888;
      border-radius: 8px;
      cursor: grab;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
    }

    .crossfader-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 0.8em;
      opacity: 0.7;
      width: 100%;
    }

    /* Controls */
    .main-controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 30px 0;
      flex-wrap: wrap;
    }

    .btn {
      padding: 15px 30px;
      font-size: 1.1em;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 120px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #ff0080, #7928ca);
      color: white;
      box-shadow: 0 4px 15px rgba(255, 0, 128, 0.3);
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 0, 128, 0.5);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Status */
    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      padding: 15px 20px;
      margin: 20px 0;
      font-size: 0.9em;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-value {
      font-weight: 600;
      color: #1db954;
    }

    .status-value.warning {
      color: #ff9500;
    }

    .status-value.error {
      color: #ff0080;
    }

    /* Login Section */
    .login-section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 20px;
      padding: 50px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: 500px;
      margin: 0 auto;
    }

    .login-title {
      font-size: 2.5em;
      margin-bottom: 20px;
      font-weight: 300;
    }

    .login-description {
      margin-bottom: 30px;
      line-height: 1.6;
      opacity: 0.9;
    }

    /* Loading */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .loading-overlay.active {
      display: flex;
    }

    .loader {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top: 3px solid #ff0080;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header h1 { font-size: 2.5em; }
      .deck-section { 
        grid-template-columns: 1fr; 
        gap: 20px; 
      }
      .crossfader-section { 
        order: -1; 
        margin-bottom: 20px;
      }
      .main-controls {
        flex-direction: column;
        align-items: center;
      }
      .btn {
        width: 100%;
        max-width: 200px;
      }
    }

    /* Notification */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      border-radius: 10px;
      padding: 15px 20px;
      border-left: 4px solid #1db954;
      backdrop-filter: blur(20px);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 1000;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.error {
      border-left-color: #ff0080;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>AI DJ</h1>
      <p class="subtitle">Intelligent Beat Mixing</p>
    </div>

    <!-- Login Section -->
    <div id="login-section" class="login-section">
      <h2 class="login-title">🎧 AI DJ</h2>
      <p class="login-description">
        Smart beat matching and seamless transitions powered by AI. 
        Connect your Spotify to start mixing like a pro.
      </p>
      <button onclick="login()" class="btn btn-primary">Connect Spotify</button>
      <p style="margin-top: 20px; font-size: 0.8em; opacity: 0.6;">
        Spotify Premium required
      </p>
    </div>

    <!-- Main DJ Interface -->
    <div id="main-interface" style="display: none;">
      <div class="dj-interface">
        <!-- Status Bar -->
        <div class="status-bar">
          <div class="status-item">
            <span>🎵 Status:</span>
            <span class="status-value" id="system-status">Ready</span>
          </div>
          <div class="status-item">
            <span>🎯 Beat Match:</span>
            <span class="status-value" id="beat-match">--</span>
          </div>
          <div class="status-item">
            <span>🔄 Auto Mix:</span>
            <span class="status-value" id="auto-status">OFF</span>
          </div>
        </div>

        <!-- Deck Section -->
        <div class="deck-section">
          <!-- Deck A -->
          <div class="deck deck-a">
            <div class="deck-label">Deck A</div>
            <div class="track-info">
              <div class="track-name" id="track-a-name">No Track</div>
              <div class="track-artist" id="track-a-artist">Load a track</div>
            </div>
            <div class="bpm-display" id="bpm-a">--</div>
          </div>

          <!-- Crossfader -->
          <div class="crossfader-section">
            <div class="crossfader-label">Mix</div>
            <div class="crossfader-container">
              <input type="range" class="crossfader" id="crossfader" 
                     min="0" max="100" value="0" step="1">
              <div class="crossfader-labels">
                <span>A</span>
                <span>B</span>
              </div>
            </div>
          </div>

          <!-- Deck B -->
          <div class="deck deck-b">
            <div class="deck-label">Deck B</div>
            <div class="track-info">
              <div class="track-name" id="track-b-name">No Track</div>
              <div class="track-artist" id="track-b-artist">Ready to queue</div>
            </div>
            <div class="bpm-display" id="bpm-b">--</div>
          </div>
        </div>

        <!-- Main Controls -->
        <div class="main-controls">
          <button onclick="smartMix()" class="btn btn-primary" id="mix-btn">
            🎛️ AI Mix
          </button>
          <button onclick="togglePlayPause()" class="btn btn-secondary" id="play-btn">
            ▶️ Play
          </button>
          <button onclick="loadNextTrack()" class="btn btn-secondary">
            ⏭️ Next
          </button>
          <button onclick="toggleAutoMix()" class="btn btn-secondary" id="auto-btn">
            🔄 Auto
          </button>
        </div>

        <button onclick="logout()" class="btn btn-secondary" style="margin-top: 20px; font-size: 0.9em;">
          Disconnect
        </button>
      </div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading-overlay">
    <div class="loader"></div>
  </div>

  <!-- Notification -->
  <div class="notification" id="notification"></div>

  <script>
    // Configuration
    const CLIENT_ID = 'e60ede83721246198bf4fe8a9bee8ca8';
    const REDIRECT_URI = window.location.origin + window.location.pathname;
    const SCOPES = [
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-currently-playing',
      'streaming',
      'user-read-recently-played'
    ];

    // Global state
    let accessToken = null;
    let deckA = { track: null, bpm: 0 };
    let deckB = { track: null, bpm: 0 };
    let autoMixActive = false;
    let isPlaying = false;
    let mixInProgress = false;

    // Simple DJ AI for beat matching
    class SimpleDJ {
      calculateBPMMatch(bpm1, bpm2) {
        if (!bpm1 || !bpm2) return 0;
        const diff = Math.abs(bpm1 - bpm2);
        const match = Math.max(0, 100 - (diff * 2));
        return Math.round(match);
      }

      findOptimalMixPoint(trackA, trackB) {
        // Simple mix point calculation
        const bpmMatch = this.calculateBPMMatch(trackA.bpm, trackB.bpm);
        return {
          mixDuration: bpmMatch > 80 ? 16000 : 8000, // 16s or 8s mix
          confidence: bpmMatch / 100
        };
      }
    }

    const djAI = new SimpleDJ();

    // Authentication
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function generateRandomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    async function login() {
      try {
        const state = generateRandomString(16);
        const codeVerifier = generateRandomString(128);
        const codeChallenge = await generateCodeChallenge(codeVerifier);
        
        sessionStorage.setItem('code_verifier', codeVerifier);
        sessionStorage.setItem('state', state);
        
        const authUrl = new URL('https://accounts.spotify.com/authorize');
        authUrl.searchParams.set('response_type', 'code');
        authUrl.searchParams.set('client_id', CLIENT_ID);
        authUrl.searchParams.set('scope', SCOPES.join(' '));
        authUrl.searchParams.set('redirect_uri', REDIRECT_URI);
        authUrl.searchParams.set('state', state);
        authUrl.searchParams.set('code_challenge_method', 'S256');
        authUrl.searchParams.set('code_challenge', codeChallenge);
        
        window.location = authUrl.toString();
      } catch (error) {
        showNotification('Login failed: ' + error.message, 'error');
      }
    }

    async function handleRedirect() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');
      const error = params.get('error');

      if (error) {
        showNotification('Authentication failed', 'error');
        return;
      }

      if (!code) return;

      try {
        showLoading();
        
        const storedState = sessionStorage.getItem('state');
        if (state !== storedState) {
          throw new Error('Invalid state');
        }

        const codeVerifier = sessionStorage.getItem('code_verifier');
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code,
            redirect_uri: REDIRECT_URI,
            client_id: CLIENT_ID,
            code_verifier: codeVerifier
          })
        });

        const data = await response.json();
        if (!data.access_token) {
          throw new Error('No access token');
        }

        accessToken = data.access_token;
        sessionStorage.setItem('access_token', data.access_token);
        
        window.history.replaceState({}, document.title, window.location.pathname);
        
        await initializeDJ();
        
      } catch (error) {
        showNotification('Setup failed: ' + error.message, 'error');
      } finally {
        hideLoading();
      }
    }

    // Spotify API
    async function spotifyRequest(endpoint, options = {}) {
      try {
        const response = await fetch(`https://api.spotify.com/v1${endpoint}`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json',
            ...options.headers
          },
          ...options
        });

        if (response.status === 204) return {};
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        return await response.json();
      } catch (error) {
        console.error('Spotify API error:', error);
        return null;
      }
    }

    // DJ Functions
    async function initializeDJ() {
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('main-interface').style.display = 'block';
      
      updateStatus('Connected', 'success');
      showNotification('DJ System Ready!');
      
      // Load current track
      await loadCurrentTrack();
      
      // Start monitoring
      setInterval(updateInterface, 2000);
    }

    async function loadCurrentTrack() {
      const playback = await spotifyRequest('/me/player');
      if (playback && playback.item) {
        await loadToDeck('A', playback.item);
        isPlaying = playback.is_playing;
        updatePlayButton();
      }
    }

    async function loadToDeck(deck, track) {
      showLoading();
      
      try {
        // Get audio features for BPM
        const features = await spotifyRequest(`/audio-features/${track.id}`);
        const bpm = features ? Math.round(features.tempo) : 0;
        
        if (deck === 'A') {
          deckA = { track, bpm };
          updateDeckDisplay('A', track, bpm);
        } else {
          deckB = { track, bpm };
          updateDeckDisplay('B', track, bpm);
        }
        
        updateBeatMatch();
        
      } catch (error) {
        showNotification('Failed to load track', 'error');
      } finally {
        hideLoading();
      }
    }

    function updateDeckDisplay(deck, track, bpm) {
      const deckLower = deck.toLowerCase();
      document.getElementById(`track-${deckLower}-name`).textContent = track.name;
      document.getElementById(`track-${deckLower}-artist`).textContent = track.artists[0].name;
      document.getElementById(`bpm-${deckLower}`).textContent = bpm || '--';
    }

    function updateBeatMatch() {
      if (deckA.bpm && deckB.bpm) {
        const match = djAI.calculateBPMMatch(deckA.bpm, deckB.bpm);
        const element = document.getElementById('beat-match');
        element.textContent = match + '%';
        
        if (match > 80) {
          element.className = 'status-value';
        } else if (match > 50) {
          element.className = 'status-value warning';
        } else {
          element.className = 'status-value error';
        }
      }
    }

    // Main Controls
    async function smartMix() {
      if (mixInProgress) return;
      
      mixInProgress = true;
      const btn = document.getElementById('mix-btn');
      btn.disabled = true;
      btn.textContent = '🎛️ Mixing...';
      
      try {
        // Load next track to Deck B if empty
        if (!deckB.track) {
          const queue = await spotifyRequest('/me/player/queue');
          if (queue && queue.queue && queue.queue.length > 0) {
            await loadToDeck('B', queue.queue[0]);
          } else {
            throw new Error('No tracks in queue');
          }
        }
        
        updateStatus('Mixing', 'mixing');
        
        // Simple mix: skip to next track
        await spotifyRequest('/me/player/next', { method: 'POST' });
        
        // Wait and update
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Swap decks
        deckA = deckB;
        deckB = { track: null, bpm: 0 };
        
        // Update display
        updateDeckDisplay('A', deckA.track, deckA.bpm);
        document.getElementById('track-b-name').textContent = 'No Track';
        document.getElementById('track-b-artist').textContent = 'Ready to queue';
        document.getElementById('bpm-b').textContent = '--';
        
        updateBeatMatch();
        updateStatus('Connected', 'success');
        showNotification('Mix complete!');
        
      } catch (error) {
        showNotification('Mix failed: ' + error.message, 'error');
        updateStatus('Error', 'error');
      } finally {
        mixInProgress = false;
        btn.disabled = false;
        btn.textContent = '🎛️ AI Mix';
      }
    }

    async function togglePlayPause() {
      try {
        const playback = await spotifyRequest('/me/player');
        if (playback && playback.is_playing) {
          await spotifyRequest('/me/player/pause', { method: 'PUT' });
          isPlaying = false;
        } else {
          await spotifyRequest('/me/player/play', { method: 'PUT' });
          isPlaying = true;
        }
        updatePlayButton();
      } catch (error) {
        showNotification('Playback control failed', 'error');
      }
    }

    async function loadNextTrack() {
      const queue = await spotifyRequest('/me/player/queue');
      if (queue && queue.queue && queue.queue.length > 0) {
        await loadToDeck('B', queue.queue[0]);
        showNotification('Track loaded to Deck B');
      } else {
        showNotification('No tracks in queue', 'error');
      }
    }

    function toggleAutoMix() {
      autoMixActive = !autoMixActive;
      const btn = document.getElementById('auto-btn');
      const status = document.getElementById('auto-status');
      
      if (autoMixActive) {
        btn.style.background = 'linear-gradient(135deg, #1db954, #1ed760)';
        status.textContent = 'ON';
        showNotification('Auto Mix enabled');
      } else {
        btn.style.background = '';
        status.textContent = 'OFF';
        showNotification('Auto Mix disabled');
      }
    }

    // UI Updates
    function updatePlayButton() {
      const btn = document.getElementById('play-btn');
      btn.textContent = isPlaying ? '⏸️ Pause' : '▶️ Play';
    }

    function updateStatus(message, type) {
      const element = document.getElementById('system-status');
      element.textContent = message;
      element.className = `status-value ${type === 'error' ? 'error' : type === 'mixing' ? 'warning' : ''}`;
    }

    async function updateInterface() {
      if (!accessToken) return;
      
      // Update current track if changed
      const playback = await spotifyRequest('/me/player');
      if (playback && playback.item && playback.item.id !== deckA.track?.id) {
        await loadToDeck('A', playback.item);
      }
      
      if (playback) {
        isPlaying = playback.is_playing;
        updatePlayButton();
      }
    }

    // Utility Functions
    function showLoading() {
      document.getElementById('loading-overlay').classList.add('active');
    }

    function hideLoading() {
      document.getElementById('loading-overlay').classList.remove('active');
    }

    function showNotification(message, type = 'success') {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.className = `notification ${type} show`;
      
      setTimeout(() => {
        notification.classList.remove('show');
      }, 3000);
    }

    function logout() {
      accessToken = null;
      sessionStorage.clear();
      window.location.reload();
    }

    // Initialize
    window.onload = async function() {
      const storedToken = sessionStorage.getItem('access_token');
      if (storedToken) {
        accessToken = storedToken;
        await initializeDJ();
      } else {
        await handleRedirect();
      }
    };

    // Crossfader control
    document.getElementById('crossfader')?.addEventListener('input', (e) => {
      const value = e.target.value;
      // Visual feedback only - real implementation would control audio
      console.log(`Crossfader: ${value}%`);
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (!accessToken) return;
      
      switch(e.code) {
        case 'Space':
          e.preventDefault();
          togglePlayPause();
          break;
        case 'KeyM':
          e.preventDefault();
          smartMix();
          break;
        case 'KeyA':
          e.preventDefault();
          toggleAutoMix();
          break;
      }
    });
  </script>
</body>
</html>

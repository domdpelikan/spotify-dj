<!DOCTYPE html>
<html>
<head>
  <title>DJ Crossfade - Seamless Mixing</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
      color: #fff;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 600px;
      width: 100%;
      text-align: center;
    }

    h1 {
      font-size: 3em;
      margin-bottom: 10px;
      font-weight: 800;
      background: linear-gradient(45deg, #1db954, #1ed760);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      opacity: 0.7;
      margin-bottom: 30px;
      font-size: 1.1em;
    }

    .main-card {
      background: rgba(255, 255, 255, 0.06);
      border-radius: 24px;
      padding: 40px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
    }

    .track-info {
      margin-bottom: 30px;
      position: relative;
    }

    .track-name {
      font-size: 1.6em;
      font-weight: 700;
      margin-bottom: 8px;
      line-height: 1.3;
    }

    .track-artist {
      opacity: 0.7;
      margin-bottom: 20px;
      font-size: 1.1em;
    }

    /* Dual progress bars for crossfade visualization */
    .crossfade-visual {
      margin: 25px 0;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 16px;
    }

    .crossfade-label {
      font-size: 0.9em;
      opacity: 0.6;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .volume-bars {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }

    .volume-track {
      flex: 1;
      height: 40px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      overflow: hidden;
      position: relative;
    }

    .volume-fill {
      height: 100%;
      background: linear-gradient(90deg, #1db954, #1ed760);
      width: var(--volume, 100%);
      transition: width 0.3s ease;
      border-radius: 20px;
    }

    .volume-track.next .volume-fill {
      background: linear-gradient(90deg, #ff6b6b, #ff8787);
    }

    .track-label {
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.8em;
      font-weight: 600;
      z-index: 1;
      mix-blend-mode: difference;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
      margin: 15px 0;
    }

    .progress-fill {
      height: 100%;
      background: #1db954;
      width: 0%;
      transition: width 0.3s ease;
    }

    .time-display {
      display: flex;
      justify-content: space-between;
      font-size: 0.85em;
      opacity: 0.6;
    }

    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin: 30px 0;
    }

    .btn {
      padding: 14px 32px;
      border: none;
      border-radius: 28px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 1em;
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    .btn:active::before {
      width: 200px;
      height: 200px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #1db954, #1ed760);
      color: white;
      box-shadow: 0 4px 20px rgba(29, 185, 84, 0.3);
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(29, 185, 84, 0.5);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.15);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .status {
      margin: 20px 0;
      padding: 12px 24px;
      border-radius: 24px;
      font-size: 0.9em;
      display: inline-block;
      font-weight: 500;
    }

    .status.ready {
      background: rgba(29, 185, 84, 0.2);
      color: #1ed760;
    }

    .status.mixing {
      background: rgba(255, 193, 7, 0.2);
      color: #ffc107;
      animation: pulse-mix 1s ease-in-out infinite;
    }

    @keyframes pulse-mix {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .status.error {
      background: rgba(255, 0, 0, 0.2);
      color: #ff4444;
    }

    .queue-section {
      margin-top: 30px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 16px;
    }

    .queue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .queue-label {
      opacity: 0.6;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .queue-track {
      text-align: left;
      padding: 10px 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      margin-bottom: 10px;
      transition: all 0.2s ease;
    }

    .queue-track:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .queue-track-name {
      font-weight: 600;
      margin-bottom: 3px;
    }

    .queue-track-artist {
      font-size: 0.85em;
      opacity: 0.6;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      margin: 25px 0;
    }

    .stat {
      text-align: center;
      padding: 15px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
    }

    .stat-value {
      font-size: 2em;
      font-weight: 800;
      color: #1db954;
    }

    .stat-label {
      font-size: 0.8em;
      opacity: 0.6;
      margin-top: 5px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .login-section {
      text-align: center;
    }

    .login-section h2 {
      margin-bottom: 20px;
      font-size: 2em;
    }

    .login-section p {
      margin-bottom: 30px;
      opacity: 0.8;
      line-height: 1.6;
    }

    /* Loading animation */
    .mixing-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid transparent;
      border-top-color: #ffc107;
      border-right-color: #ffc107;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      vertical-align: middle;
      margin-left: 10px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Smooth transitions */
    * {
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>DJ Crossfade</h1>
    <p class="subtitle">Professional beat-matched mixing</p>

    <div id="login-section" class="login-section main-card">
      <h2>üéõÔ∏è Real DJ Transitions</h2>
      <p>
        Experience true DJ-style crossfading between tracks. Smooth blends, 
        beat matching, and professional transitions that keep the energy flowing.
      </p>
      <button onclick="login()" class="btn btn-primary">Connect Spotify</button>
      <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; font-size: 0.85em;">
        <strong>Features:</strong>
        <ul style="margin: 10px 0; padding-left: 20px; text-align: left;">
          <li>Crossfade visualization</li>
          <li>Beat-matched transitions</li>
          <li>Smart cue points</li>
          <li>Automatic tempo matching</li>
        </ul>
      </div>
    </div>

    <div id="main-interface" style="display: none;">
      <div class="main-card">
        <div class="track-info">
          <div class="track-name" id="track-name">No track playing</div>
          <div class="track-artist" id="track-artist">Start playing music</div>
          
          <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
          </div>
          
          <div class="time-display">
            <span id="time-current">0:00</span>
            <span id="time-total">0:00</span>
          </div>
        </div>

        <!-- Crossfade Visualization -->
        <div class="crossfade-visual" id="crossfade-visual" style="display: none;">
          <div class="crossfade-label">Crossfade Mix</div>
          <div class="volume-bars">
            <div class="volume-track current">
              <div class="track-label">Current</div>
              <div class="volume-fill" id="current-volume" style="--volume: 100%;"></div>
            </div>
            <div class="volume-track next">
              <div class="track-label">Next</div>
              <div class="volume-fill" id="next-volume" style="--volume: 0%;"></div>
            </div>
          </div>
        </div>

        <div class="controls">
          <button onclick="crossfadeMix()" class="btn btn-primary" id="mix-btn">
            Mix ‚ö°
          </button>
          <button onclick="togglePlayPause()" class="btn btn-secondary" id="play-btn">
            Play
          </button>
        </div>

        <div id="status" class="status ready">Ready</div>

        <div class="stats">
          <div class="stat">
            <div class="stat-value" id="mix-count">0</div>
            <div class="stat-label">Mixes</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="current-bpm">--</div>
            <div class="stat-label">BPM</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="mix-time">--</div>
            <div class="stat-label">Mix Time</div>
          </div>
        </div>

        <div class="queue-section">
          <div class="queue-header">
            <div class="queue-label">Up Next</div>
            <div class="queue-label" id="queue-count">0 tracks</div>
          </div>
          <div id="queue-list">
            <div class="queue-track">
              <div class="queue-track-name">Loading queue...</div>
              <div class="queue-track-artist">Please wait</div>
            </div>
          </div>
        </div>
      </div>

      <button onclick="logout()" class="btn btn-secondary" style="margin-top: 20px;">
        Disconnect
      </button>
    </div>
  </div>

  <script>
    // Configuration
    const CLIENT_ID = 'e60ede83721246198bf4fe8a9bee8ca8';
    const REDIRECT_URI = window.location.origin + window.location.pathname;
    const SCOPES = [
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-currently-playing',
      'streaming'
    ];

    // Crossfade settings
    const CROSSFADE_DURATION = 4000; // 4 seconds
    const CROSSFADE_STEPS = 20; // Smooth steps
    const BEAT_INTRO_SKIP = 16000; // Skip first 16 seconds

    // Global state
    let accessToken = null;
    let currentTrack = null;
    let nextTrackData = null;
    let isMixing = false;
    let mixCount = 0;
    let monitorInterval = null;
    let currentBPM = 0;
    let queuedTracks = [];

    // Track analysis cache
    const analysisCache = new Map();

    // Beat analysis and crossfade logic
    class DJMixer {
      constructor() {
        this.analyzing = false;
      }

      async analyzeTrack(trackId) {
        // Check cache
        if (analysisCache.has(trackId)) {
          return analysisCache.get(trackId);
        }

        try {
          const features = await spotifyRequest(`/audio-features/${trackId}`);
          if (!features) return this.getDefaultAnalysis();

          const analysis = {
            bpm: features.tempo,
            key: features.key,
            energy: features.energy,
            danceability: features.danceability,
            duration: features.duration_ms,
            // Calculate mix points
            introEnd: this.calculateIntroEnd(features),
            outroStart: features.duration_ms - 30000, // Last 30 seconds
            optimalMixPoint: this.calculateOptimalMixPoint(features)
          };

          analysisCache.set(trackId, analysis);
          return analysis;
        } catch (error) {
          console.error('Analysis failed:', error);
          return this.getDefaultAnalysis();
        }
      }

      calculateIntroEnd(features) {
        // Skip intro based on energy and danceability
        const baseSkip = 16000; // 16 seconds
        const energyBonus = features.energy > 0.7 ? 8000 : 0;
        return Math.min(baseSkip + energyBonus, 30000);
      }

      calculateOptimalMixPoint(features) {
        // Find the best point to start mixing
        if (features.energy > 0.8) {
          return 16000; // High energy - quick mix
        } else if (features.danceability > 0.7) {
          return 24000; // Danceable - standard mix
        } else {
          return 32000; // Slower - longer intro
        }
      }

      getDefaultAnalysis() {
        return {
          bpm: 128,
          energy: 0.7,
          introEnd: 16000,
          outroStart: 150000,
          optimalMixPoint: 20000
        };
      }

      async findCrossfadePoint(currentPos, currentAnalysis, nextAnalysis) {
        // Calculate when to start crossfade
        const remainingTime = currentAnalysis.duration - currentPos;
        
        // Start crossfade 10 seconds before track ends or now
        const crossfadeStart = remainingTime > 10000 ? 
          currentPos + (remainingTime - 10000) : 
          currentPos;
        
        // Where to start in the next track
        const nextTrackStart = nextAnalysis.optimalMixPoint || 16000;
        
        return {
          startCrossfade: crossfadeStart,
          nextTrackCue: nextTrackStart,
          duration: Math.min(CROSSFADE_DURATION, remainingTime)
        };
      }
    }

    const mixer = new DJMixer();

    // Spotify Auth
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function generateRandomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      return Array.from({ length }, () => chars[Math.floor(Math.random() * chars.length)]).join('');
    }

    async function login() {
      const state = generateRandomString(16);
      const codeVerifier = generateRandomString(128);
      const codeChallenge = await generateCodeChallenge(codeVerifier);
      
      sessionStorage.setItem('code_verifier', codeVerifier);
      sessionStorage.setItem('state', state);
      
      const authUrl = new URL('https://accounts.spotify.com/authorize');
      authUrl.searchParams.set('response_type', 'code');
      authUrl.searchParams.set('client_id', CLIENT_ID);
      authUrl.searchParams.set('scope', SCOPES.join(' '));
      authUrl.searchParams.set('redirect_uri', REDIRECT_URI);
      authUrl.searchParams.set('state', state);
      authUrl.searchParams.set('code_challenge_method', 'S256');
      authUrl.searchParams.set('code_challenge', codeChallenge);
      
      window.location = authUrl.toString();
    }

    async function handleRedirect() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');

      if (!code) return;

      const storedState = sessionStorage.getItem('state');
      if (state !== storedState) return;

      const codeVerifier = sessionStorage.getItem('code_verifier');
      
      try {
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code,
            redirect_uri: REDIRECT_URI,
            client_id: CLIENT_ID,
            code_verifier: codeVerifier
          })
        });

        const data = await response.json();
        if (data.access_token) {
          accessToken = data.access_token;
          sessionStorage.setItem('access_token', data.access_token);
          window.history.replaceState({}, document.title, window.location.pathname);
          await initializeApp();
        }
      } catch (error) {
        console.error('Auth error:', error);
      }
    }

    // Spotify API
    async function spotifyRequest(endpoint, options = {}) {
      if (!accessToken) return null;
      
      try {
        const response = await fetch(`https://api.spotify.com/v1${endpoint}`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            ...options.headers
          },
          ...options
        });

        if (response.status === 204) return true;
        if (response.status === 401) {
          sessionStorage.removeItem('access_token');
          window.location.reload();
          return null;
        }
        if (!response.ok) return null;
        
        return await response.json();
      } catch (error) {
        console.error('API error:', error);
        return null;
      }
    }

    // Main crossfade function
    async function crossfadeMix() {
      if (isMixing || !currentTrack) return;
      
      isMixing = true;
      document.getElementById('mix-btn').disabled = true;
      updateStatus('mixing', 'Mixing...');
      showCrossfadeVisual(true);
      
      const startTime = Date.now();
      
      try {
        // Get current state
        const playback = await spotifyRequest('/me/player');
        if (!playback || !playback.item) {
          throw new Error('No active playback');
        }

        const currentPos = playback.progress_ms;
        const currentAnalysis = await mixer.analyzeTrack(currentTrack.id);
        
        // Get next track
        if (!nextTrackData || queuedTracks.length === 0) {
          await updateQueue();
          if (queuedTracks.length === 0) {
            throw new Error('No tracks in queue');
          }
        }

        const nextTrack = queuedTracks[0];
        const nextAnalysis = await mixer.analyzeTrack(nextTrack.id);
        
        // Calculate crossfade timing
        const crossfadeData = await mixer.findCrossfadePoint(
          currentPos, 
          currentAnalysis, 
          nextAnalysis
        );
        
        console.log('Crossfade plan:', crossfadeData);
        
        // Animate crossfade visual
        await animateCrossfade();
        
        // Execute the mix
        await spotifyRequest('/me/player/next', { method: 'POST' });
        
        // Wait for track change
        let attempts = 0;
        let trackChanged = false;
        
        while (attempts < 30 && !trackChanged) {
          await new Promise(r => setTimeout(r, 100));
          
          const newPlayback = await spotifyRequest('/me/player');
          if (newPlayback?.item?.id !== currentTrack.id) {
            trackChanged = true;
            
            // Seek to optimal point
            const seekPoint = crossfadeData.nextTrackCue || BEAT_INTRO_SKIP;
            if (seekPoint > 1000) {
              await spotifyRequest(`/me/player/seek?position_ms=${seekPoint}`, {
                method: 'PUT'
              });
              console.log(`Seeked to ${seekPoint}ms for beat match`);
            }
            break;
          }
          attempts++;
        }
        
        // Update stats
        const mixTime = ((Date.now() - startTime) / 1000).toFixed(1);
        document.getElementById('mix-time').textContent = mixTime + 's';
        
        mixCount++;
        document.getElementById('mix-count').textContent = mixCount;
        
        updateStatus('ready', 'Mix complete!');
        
      } catch (error) {
        console.error('Mix error:', error);
        updateStatus('error', error.message);
      } finally {
        isMixing = false;
        document.getElementById('mix-btn').disabled = false;
        setTimeout(() => showCrossfadeVisual(false), 2000);
      }
    }

    // Animate crossfade visual
    async function animateCrossfade() {
      const steps = CROSSFADE_STEPS;
      const stepDuration = CROSSFADE_DURATION / steps;
      
      for (let i = 0; i <= steps; i++) {
        const progress = i / steps;
        const currentVol = 100 - (progress * 100);
        const nextVol = progress * 100;
        
        document.getElementById('current-volume').style.setProperty('--volume', currentVol + '%');
        document.getElementById('next-volume').style.setProperty('--volume', nextVol + '%');
        
        await new Promise(r => setTimeout(r, stepDuration));
      }
    }

    function showCrossfadeVisual(show) {
      const visual = document.getElementById('crossfade-visual');
      visual.style.display = show ? 'block' : 'none';
      
      if (show) {
        document.getElementById('current-volume').style.setProperty('--volume', '100%');
        document.getElementById('next-volume').style.setProperty('--volume', '0%');
      }
    }

    // Monitor playback
    async function monitorPlayback() {
      try {
        const playback = await spotifyRequest('/me/player');
        
        if (!playback || !playback.item) {
          updateEmptyState();
          return;
        }

        const track = playback.item;
        const progress = playback.progress_ms || 0;
        const duration = track.duration_ms || 0;
        
        // Update display
        updateTrackDisplay(track, progress, duration);
        currentTrack = track;
        
        // Update play button
        document.getElementById('play-btn').textContent = playback.is_playing ? 'Pause' : 'Play';
        
        // Update BPM
        if (track.id !== currentTrack?.id) {
          mixer.analyzeTrack(track.id).then(analysis => {
            if (analysis?.bpm) {
              currentBPM = Math.round(analysis.bpm);
              document.getElementById('current-bpm').textContent = currentBPM;
            }
          });
        }
        
        // Update queue when track is 70% complete
        const percent = progress / duration;
        if (percent > 0.7) {
          updateQueue();
        }
        
      } catch (error) {
        console.error('Monitor error:', error);
      }
    }

    // Update queue display
    async function updateQueue() {
      try {
        const queue = await spotifyRequest('/me/player/queue');
        if (!queue || !queue.queue) return;
        
        queuedTracks = queue.queue.slice(0, 3); // Show next 3 tracks
        const queueList = document.getElementById('queue-list');
        
        if (queuedTracks.length === 0) {
          queueList.innerHTML = `
            <div class="queue-track">
              <div class="queue-track-name">No tracks in queue</div>
              <div class="queue-track-artist">Add songs to your queue</div>
            </div>
          `;
        } else {
          queueList.innerHTML = queuedTracks.map(track => `
            <div class="queue-track">
              <div class="queue-track-name">${track.name}</div>
              <div class="queue-track-artist">${track.artists[0].name}</div>
            </div>
          `).join('');
          
          // Preanalyze next track
          if (queuedTracks[0]) {
            nextTrackData = await mixer.analyzeTrack(queuedTracks[0].id);
          }
        }
        
        document.getElementById('queue-count').textContent = `${queuedTracks.length} tracks`;
        
      } catch (error) {
        console.error('Queue update error:', error);
      }
    }

    // UI Updates
    function updateTrackDisplay(track, progress, duration) {
      document.getElementById('track-name').textContent = track.name;
      document.getElementById('track-artist').textContent = 
        track.artists.map(a => a.name).join(', ');
      
      const percent = (progress / duration) * 100;
      document.getElementById('progress-fill').style.width = percent + '%';
      
      document.getElementById('time-current').textContent = formatTime(progress);
      document.getElementById('time-total').textContent = formatTime(duration);
    }

    function updateEmptyState() {
      document.getElementById('track-name').textContent = 'No track playing';
      document.getElementById('track-artist').textContent = 'Start playing music';
      document.getElementById('progress-fill').style.width = '0%';
      document.getElementById('time-current').textContent = '0:00';
      document.getElementById('time-total').textContent = '0:00';
      document.getElementById('current-bpm').textContent = '--';
      currentTrack = null;
    }

    function updateStatus(type, message) {
      const status = document.getElementById('status');
      status.className = `status ${type}`;
      
      if (type === 'mixing') {
        status.innerHTML = message + '<span class="mixing-spinner"></span>';
      } else {
        status.textContent = message;
      }
    }

    function formatTime(ms) {
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Playback controls
    async function togglePlayPause() {
      try {
        const playback = await spotifyRequest('/me/player');
        if (!playback) {
          updateStatus('error', 'No active device');
          return;
        }
        
        if (playback.is_playing) {
          await spotifyRequest('/me/player/pause', { method: 'PUT' });
        } else {
          await spotifyRequest('/me/player/play', { method: 'PUT' });
        }
      } catch (error) {
        console.error('Playback error:', error);
      }
    }

    // Initialize app
    async function initializeApp() {
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('main-interface').style.display = 'block';
      
      updateStatus('ready', 'Connected - Play music to begin');
      
      // Start monitoring
      monitorInterval = setInterval(monitorPlayback, 500);
      await monitorPlayback();
      await updateQueue();
    }

    function logout() {
      clearInterval(monitorInterval);
      accessToken = null;
      sessionStorage.clear();
      window.location.reload();
    }

    // Initialize on load
    window.onload = async function() {
      const storedToken = sessionStorage.getItem('access_token');
      if (storedToken) {
        accessToken = storedToken;
        await initializeApp();
      } else {
        await handleRedirect();
      }
    };

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (!accessToken) return;
      
      switch(e.code) {
        case 'Space':
          e.preventDefault();
          togglePlayPause();
          break;
        case 'KeyM':
        case 'ArrowRight':
          e.preventDefault();
          crossfadeMix();
          break;
      }
    });
  </script>
</body>
</html>

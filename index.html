<!DOCTYPE html>
<html>
<head>
  <title>AI DJ - Professional Beat Mixing</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000;
      color: white;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      position: relative;
      overflow: hidden;
    }

    /* DJ Booth Background */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 50%, rgba(138, 43, 226, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 50%, rgba(29, 185, 84, 0.3) 0%, transparent 50%),
        linear-gradient(180deg, #0a0a0a 0%, #1a1a1a 100%);
      animation: booth-lights 10s ease-in-out infinite;
    }

    @keyframes booth-lights {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    .container {
      max-width: 1200px;
      width: 100%;
      text-align: center;
      position: relative;
      z-index: 1;
    }

    .header h1 {
      font-size: 4.5em;
      font-weight: 900;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 4px;
      background: linear-gradient(45deg, #ff0080, #7928ca, #ff0080);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: neon-glow 3s ease-in-out infinite;
    }

    @keyframes neon-glow {
      0%, 100% { 
        background-position: 0% 50%;
        filter: drop-shadow(0 0 20px rgba(255, 0, 128, 0.5));
      }
      50% { 
        background-position: 100% 50%;
        filter: drop-shadow(0 0 30px rgba(121, 40, 202, 0.8));
      }
    }

    .subtitle {
      font-size: 1.4em;
      opacity: 0.9;
      margin-bottom: 30px;
      font-weight: 300;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    /* DJ Mixer Interface */
    .dj-mixer {
      background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
      border-radius: 20px;
      padding: 30px;
      margin: 30px 0;
      box-shadow: 
        0 10px 40px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      position: relative;
    }

    .deck-container {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }

    .deck {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 15px;
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .deck-label {
      font-size: 0.9em;
      text-transform: uppercase;
      opacity: 0.7;
      margin-bottom: 10px;
      letter-spacing: 1px;
    }

    .track-display {
      background: #000;
      border: 2px solid #1db954;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .track-display.deck-b {
      border-color: #ff0080;
    }

    .waveform-display {
      height: 100px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      position: relative;
      overflow: hidden;
      margin-bottom: 15px;
    }

    .waveform-scrolling {
      position: absolute;
      height: 100%;
      display: flex;
      align-items: center;
      transition: transform 0.1s linear;
    }

    .waveform-bar {
      width: 3px;
      margin: 0 1px;
      background: linear-gradient(to top, #1db954, #1ed760);
      opacity: 0.8;
    }

    .deck-b .waveform-bar {
      background: linear-gradient(to top, #ff0080, #ff4da6);
    }

    .playhead {
      position: absolute;
      left: 50%;
      top: 0;
      width: 2px;
      height: 100%;
      background: white;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
      z-index: 10;
    }

    /* Crossfader */
    .crossfader-section {
      background: rgba(0, 0, 0, 0.6);
      border-radius: 15px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .crossfader-container {
      width: 100%;
      max-width: 300px;
      margin: 20px 0;
    }

    .crossfader {
      -webkit-appearance: none;
      width: 100%;
      height: 60px;
      background: linear-gradient(to right, #1db954 0%, #333 50%, #ff0080 100%);
      border-radius: 30px;
      outline: none;
      cursor: pointer;
      position: relative;
    }

    .crossfader::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 40px;
      height: 80px;
      background: linear-gradient(145deg, #f0f0f0, #d0d0d0);
      border: 2px solid #888;
      border-radius: 10px;
      cursor: grab;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    }

    .crossfader:active::-webkit-slider-thumb {
      cursor: grabbing;
      background: linear-gradient(145deg, #d0d0d0, #b0b0b0);
    }

    .crossfader-label {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      font-size: 0.9em;
      opacity: 0.7;
    }

    /* EQ Knobs */
    .eq-section {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      margin-top: 20px;
    }

    .eq-knob {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .knob {
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, #444, #222);
      border-radius: 50%;
      position: relative;
      cursor: pointer;
      box-shadow: 
        0 5px 15px rgba(0, 0, 0, 0.5),
        inset 0 -2px 5px rgba(0, 0, 0, 0.5);
    }

    .knob::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 50%;
      width: 3px;
      height: 40%;
      background: #1db954;
      transform: translateX(-50%);
      border-radius: 2px;
    }

    .knob-label {
      margin-top: 10px;
      font-size: 0.8em;
      text-transform: uppercase;
      opacity: 0.7;
    }

    /* Effects Section */
    .effects-panel {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 15px;
      padding: 20px;
      margin: 20px 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }

    .effect-btn {
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      font-size: 0.9em;
      font-weight: 600;
      position: relative;
      overflow: hidden;
    }

    .effect-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
    }

    .effect-btn.active {
      background: linear-gradient(145deg, #1db954, #1ed760);
      border-color: #1db954;
      box-shadow: 0 0 20px rgba(29, 185, 84, 0.5);
    }

    /* BPM Display */
    .bpm-display {
      font-size: 3em;
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      margin: 10px 0;
      text-shadow: 0 0 20px currentColor;
    }

    .deck-a .bpm-display {
      color: #1db954;
    }

    .deck-b .bpm-display {
      color: #ff0080;
    }

    /* Sync indicator */
    .sync-indicator {
      display: inline-block;
      padding: 5px 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      font-size: 0.8em;
      margin-top: 10px;
    }

    .sync-indicator.synced {
      background: rgba(29, 185, 84, 0.3);
      color: #1ed760;
    }

    /* Controls */
    .transport-controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 30px 0;
    }

    .btn {
      padding: 15px 35px;
      font-size: 1.1em;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      overflow: hidden;
    }

    .btn-primary {
      background: linear-gradient(135deg, #ff0080, #7928ca);
      color: white;
      box-shadow: 0 4px 20px rgba(255, 0, 128, 0.4);
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 8px 30px rgba(255, 0, 128, 0.6);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    /* AI Status */
    .ai-dj-status {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 0, 128, 0.5);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(20px);
      max-width: 250px;
    }

    .ai-status-title {
      font-size: 1.1em;
      font-weight: 600;
      margin-bottom: 10px;
      color: #ff0080;
    }

    .ai-metric {
      display: flex;
      justify-content: space-between;
      margin: 8px 0;
      font-size: 0.9em;
    }

    .ai-metric-value {
      color: #1ed760;
      font-weight: 600;
    }

    /* Visualizer */
    .spectrum-visualizer {
      height: 150px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 15px;
      margin: 20px 0;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: flex-end;
      justify-content: space-around;
      padding: 10px;
    }

    .spectrum-bar {
      width: 4px;
      background: linear-gradient(to top, #ff0080, #7928ca, #1ed760);
      border-radius: 2px;
      transition: height 0.1s ease;
    }

    /* Loading State */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .loading-overlay.active {
      display: flex;
    }

    .turntable-loader {
      width: 100px;
      height: 100px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top: 3px solid #ff0080;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Login Section */
    .login-section {
      padding: 60px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 30px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: 600px;
      margin: 0 auto;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header h1 { font-size: 3em; }
      .deck-container { grid-template-columns: 1fr; }
      .crossfader-section { order: -1; }
      .ai-dj-status { position: relative; top: 0; right: 0; margin: 20px auto; }
    }

    /* Status Bar */
    .status {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      border-radius: 50px;
      font-weight: 600;
      font-size: 1em;
      backdrop-filter: blur(20px);
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    .status.connected {
      background: rgba(29, 185, 84, 0.2);
      border: 1px solid #1db954;
    }

    .status.mixing {
      background: rgba(255, 0, 128, 0.2);
      border: 1px solid #ff0080;
      animation: pulse-mix 1s ease-in-out infinite;
    }

    @keyframes pulse-mix {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
  </style>
</head>
<body>
  <div class="ai-dj-status">
    <div class="ai-status-title">🎧 AI DJ STATUS</div>
    <div class="ai-metric">
      <span>Mix Quality</span>
      <span class="ai-metric-value" id="mix-quality">PRO</span>
    </div>
    <div class="ai-metric">
      <span>Beat Match</span>
      <span class="ai-metric-value" id="beat-match">100%</span>
    </div>
    <div class="ai-metric">
      <span>Harmonic Mix</span>
      <span class="ai-metric-value" id="harmonic-mix">ON</span>
    </div>
    <div class="ai-metric">
      <span>Auto-Mix</span>
      <span class="ai-metric-value" id="auto-mix">READY</span>
    </div>
  </div>

  <div class="container">
    <div class="header">
      <h1>AI DJ</h1>
      <p class="subtitle">Professional Beat Mixing System</p>
    </div>

    <div id="status" class="status connected">System Ready</div>

    <div id="login-section" class="login-section">
      <h2 style="margin-bottom: 20px; font-size: 2.5em; font-weight: 300;">🎛️ Professional AI DJ</h2>
      <p style="margin-bottom: 30px; line-height: 1.8; opacity: 0.9;">
        Experience true DJ-style mixing with AI. Seamless beatmatched transitions, 
        harmonic mixing, crossfading, EQ blending, and professional effects. 
        The AI learns your style and creates perfect mixes every time.
      </p>
      <button onclick="login()" class="btn btn-primary">Launch DJ Mode</button>
      <p style="margin-top: 20px; font-size: 0.9em; opacity: 0.6;">
        Spotify Premium required • Professional mixing algorithms
      </p>
    </div>

    <div id="main-interface" class="main-interface" style="display: none;">
      <div class="dj-mixer">
        <div class="deck-container">
          <!-- Deck A -->
          <div class="deck deck-a">
            <div class="deck-label">Deck A</div>
            <div class="track-display">
              <div class="track-name" id="track-a-name">Empty</div>
              <div class="track-artist" id="track-a-artist">Load track</div>
            </div>
            <div class="waveform-display">
              <div class="waveform-scrolling" id="waveform-a"></div>
              <div class="playhead"></div>
            </div>
            <div class="bpm-display" id="bpm-a">0.0</div>
            <div class="sync-indicator" id="sync-a">NOT SYNCED</div>
            <div class="eq-section">
              <div class="eq-knob">
                <div class="knob" id="eq-high-a"></div>
                <div class="knob-label">HIGH</div>
              </div>
              <div class="eq-knob">
                <div class="knob" id="eq-mid-a"></div>
                <div class="knob-label">MID</div>
              </div>
              <div class="eq-knob">
                <div class="knob" id="eq-low-a"></div>
                <div class="knob-label">LOW</div>
              </div>
            </div>
          </div>

          <!-- Crossfader -->
          <div class="crossfader-section">
            <div class="deck-label">CROSSFADER</div>
            <div class="crossfader-container">
              <input type="range" class="crossfader" id="crossfader" 
                     min="0" max="100" value="0" step="1">
              <div class="crossfader-label">
                <span>A</span>
                <span>MIX</span>
                <span>B</span>
              </div>
            </div>
            <button class="effect-btn" id="auto-mix-btn" onclick="toggleAutoMix()">
              AUTO MIX
            </button>
          </div>

          <!-- Deck B -->
          <div class="deck deck-b">
            <div class="deck-label">Deck B</div>
            <div class="track-display deck-b">
              <div class="track-name" id="track-b-name">Empty</div>
              <div class="track-artist" id="track-b-artist">Load track</div>
            </div>
            <div class="waveform-display">
              <div class="waveform-scrolling" id="waveform-b"></div>
              <div class="playhead"></div>
            </div>
            <div class="bpm-display" id="bpm-b">0.0</div>
            <div class="sync-indicator" id="sync-b">NOT SYNCED</div>
            <div class="eq-section">
              <div class="eq-knob">
                <div class="knob" id="eq-high-b"></div>
                <div class="knob-label">HIGH</div>
              </div>
              <div class="eq-knob">
                <div class="knob" id="eq-mid-b"></div>
                <div class="knob-label">MID</div>
              </div>
              <div class="eq-knob">
                <div class="knob" id="eq-low-b"></div>
                <div class="knob-label">LOW</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Effects Panel -->
        <div class="effects-panel">
          <button class="effect-btn" onclick="applyEffect('filter')">FILTER</button>
          <button class="effect-btn" onclick="applyEffect('reverb')">REVERB</button>
          <button class="effect-btn" onclick="applyEffect('delay')">DELAY</button>
          <button class="effect-btn" onclick="applyEffect('loop')">LOOP</button>
          <button class="effect-btn" onclick="applyEffect('scratch')">SCRATCH</button>
          <button class="effect-btn" onclick="applyEffect('fade')">FADE</button>
        </div>

        <!-- Spectrum Visualizer -->
        <div class="spectrum-visualizer" id="spectrum"></div>
      </div>

      <div class="transport-controls">
        <button onclick="smartMix()" class="btn btn-primary" id="mix-btn">
          🎛️ AI MIX
        </button>
        <button onclick="togglePlayPause()" class="btn btn-secondary" id="play-btn">
          ▶️ PLAY
        </button>
        <button onclick="loadNextTrack()" class="btn btn-secondary">
          ⏭️ QUEUE
        </button>
      </div>

      <button onclick="logout()" class="btn btn-secondary" style="margin-top: 30px;">
        EXIT DJ MODE
      </button>
    </div>
  </div>

  <div class="loading-overlay" id="loading-overlay">
    <div class="turntable-loader"></div>
  </div>

  <script>
    // Configuration
    const CLIENT_ID = 'e60ede83721246198bf4fe8a9bee8ca8';
    const REDIRECT_URI = window.location.origin + window.location.pathname;
    const SCOPES = [
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-currently-playing',
      'user-read-playback-position',
      'streaming',
      'user-read-recently-played',
      'user-library-read'
    ];

    // Global state
    let accessToken = null;
    let currentDeck = 'A';
    let deckA = { track: null, analysis: null, volume: 1, eq: { high: 0, mid: 0, low: 0 } };
    let deckB = { track: null, analysis: null, volume: 0, eq: { high: 0, mid: 0, low: 0 } };
    let crossfaderPosition = 0;
    let autoMixActive = false;
    let mixInProgress = false;
    let djAI = null;

    // Professional DJ AI System
    class ProfessionalDJAI {
      constructor() {
        this.audioContext = null;
        this.analyser = null;
        
        // DJ knowledge base
        this.mixingTechniques = {
          beatmatch: { confidence: 0.9, learned: 100 },
          harmonic: { confidence: 0.85, learned: 80 },
          phrase: { confidence: 0.8, learned: 70 },
          energy: { confidence: 0.9, learned: 90 }
        };
        
        // Harmonic mixing wheel (Camelot)
        this.camelotWheel = {
          '1A': ['12A', '2A', '1B'], '1B': ['12B', '2B', '1A'],
          '2A': ['1A', '3A', '2B'], '2B': ['1B', '3B', '2A'],
          '3A': ['2A', '4A', '3B'], '3B': ['2B', '4B', '3A'],
          '4A': ['3A', '5A', '4B'], '4B': ['3B', '5B', '4A'],
          '5A': ['4A', '6A', '5B'], '5B': ['4B', '6B', '5A'],
          '6A': ['5A', '7A', '6B'], '6B': ['5B', '7B', '6A'],
          '7A': ['6A', '8A', '7B'], '7B': ['6B', '8B', '7A'],
          '8A': ['7A', '9A', '8B'], '8B': ['7B', '9B', '8A'],
          '9A': ['8A', '10A', '9B'], '9B': ['8B', '10B', '9A'],
          '10A': ['9A', '11A', '10B'], '10B': ['9B', '11B', '10A'],
          '11A': ['10A', '12A', '11B'], '11B': ['10B', '12B', '11A'],
          '12A': ['11A', '1A', '12B'], '12B': ['11B', '1B', '12A']
        };
        
        // Mix history for learning
        this.mixHistory = [];
        this.beatGrids = new Map();
        
        this.initAudio();
      }

      async initAudio() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.analyser = this.audioContext.createAnalyser();
          this.analyser.fftSize = 2048;
          this.analyser.smoothingTimeConstant = 0.8;
        } catch (e) {
          console.log('Audio context will be initialized on user interaction');
        }
      }

      // Convert key and mode to Camelot notation
      toCamelot(key, mode) {
        const keyMap = {
          0: mode ? '8B' : '5A',   // C
          1: mode ? '3B' : '12A',  // C#/Db
          2: mode ? '10B' : '7A',  // D
          3: mode ? '5B' : '2A',   // D#/Eb
          4: mode ? '12B' : '9A',  // E
          5: mode ? '7B' : '4A',   // F
          6: mode ? '2B' : '11A',  // F#/Gb
          7: mode ? '9B' : '6A',   // G
          8: mode ? '4B' : '1A',   // G#/Ab
          9: mode ? '11B' : '8A',  // A
          10: mode ? '6B' : '3A',  // A#/Bb
          11: mode ? '1B' : '10A'  // B
        };
        return keyMap[key] || '5A';
      }

      // Analyze track for DJ mixing
      async analyzeForMixing(trackId) {
        try {
          const [features, analysis, track] = await Promise.all([
            spotifyRequest(`/audio-features/${trackId}`),
            this.getDetailedAnalysis(trackId),
            spotifyRequest(`/tracks/${trackId}`)
          ]);

          if (!features) return null;

          const camelotKey = this.toCamelot(features.key, features.mode);
          
          return {
            id: trackId,
            name: track?.name || 'Unknown',
            artist: track?.artists?.[0]?.name || 'Unknown',
            
            // Timing
            tempo: features.tempo,
            time_signature: features.time_signature,
            duration_ms: features.duration_ms,
            
            // Harmonic
            key: features.key,
            mode: features.mode,
            camelotKey: camelotKey,
            compatibleKeys: this.camelotWheel[camelotKey] || [],
            
            // Energy & Mood
            energy: features.energy,
            danceability: features.danceability,
            valence: features.valence,
            
            // Mix points
            introOutroBeats: this.detectIntroOutro(analysis),
            phrases: this.detectPhrases(analysis),
            breakdowns: this.detectBreakdowns(analysis),
            
            // Beatgrid
            beatGrid: this.generateBeatGrid(features.tempo, features.duration_ms)
          };
        } catch (error) {
          console.error('Mix analysis failed:', error);
          return this.generateFallbackAnalysis(trackId);
        }
      }

      // Detailed analysis for professional mixing
      async getDetailedAnalysis(trackId) {
        try {
          const analysis = await spotifyRequest(`/audio-analysis/${trackId}`);
          return analysis || {};
        } catch (error) {
          return {};
        }
      }

      // Detect intro and outro sections
      detectIntroOutro(analysis) {
        if (!analysis || !analysis.sections) {
          return { intro: 0, outro: 180000 }; // Default 3 min
        }

        const sections = analysis.sections;
        const intro = sections[0]?.start * 1000 || 0;
        const outro = sections[sections.length - 1]?.start * 1000 || 180000;

        return { intro, outro };
      }

      // Detect 16/32 bar phrases for mixing
      detectPhrases(analysis) {
        const phrases = [];
        const barLength = 60000 / (analysis?.track?.tempo || 120) * 4; // 4 beats per bar
        const phraseLength = barLength * 16; // 16 bar phrases

        for (let time = 0; time < (analysis?.track?.duration || 180) * 1000; time += phraseLength) {
          phrases.push({
            start: time,
            end: time + phraseLength,
            type: this.classifyPhrase(time, analysis)
          });
        }

        return phrases;
      }

      classifyPhrase(time, analysis) {
        // Classify phrase type based on position and energy
        const relativePosition = time / ((analysis?.track?.duration || 180) * 1000);
        
        if (relativePosition < 0.1) return 'intro';
        if (relativePosition > 0.9) return 'outro';
        if (relativePosition > 0.4 && relativePosition < 0.6) return 'breakdown';
        
        return 'main';
      }

      // Detect breakdowns and builds
      detectBreakdowns(analysis) {
        const breakdowns = [];
        
        if (analysis?.sections) {
          analysis.sections.forEach((section, idx) => {
            if (section.loudness < -15 || section.tempo_confidence < 0.5) {
              breakdowns.push({
                start: section.start * 1000,
                duration: section.duration * 1000,
                type: 'breakdown'
              });
            }
          });
        }
        
        return breakdowns;
      }

      // Generate precise beat grid
      generateBeatGrid(tempo, duration) {
        const beatGrid = [];
        const msPerBeat = 60000 / tempo;
        const totalBeats = Math.floor(duration / msPerBeat);

        for (let i = 0; i < totalBeats; i++) {
          beatGrid.push({
            time: i * msPerBeat,
            beat: i % 4 + 1,
            bar: Math.floor(i / 4) + 1,
            phrase: Math.floor(i / 64) + 1 // 16 bar phrases
          });
        }

        return beatGrid;
      }

      // Calculate optimal mix point
      async calculateMixPoint(trackA, trackB, currentPosition) {
        if (!trackA || !trackB) return null;

        // Check harmonic compatibility
        const harmonicScore = this.calculateHarmonicScore(trackA, trackB);
        
        // Check tempo compatibility
        const tempoRatio = Math.min(trackA.tempo, trackB.tempo) / Math.max(trackA.tempo, trackB.tempo);
        const tempoScore = tempoRatio > 0.95 ? 1 : tempoRatio;
        
        // Find optimal cue points
        const cuePoints = this.findCuePoints(trackA, trackB, currentPosition);
        
        // Calculate mix duration based on track characteristics
        const mixDuration = this.calculateMixDuration(trackA, trackB);
        
        return {
          cueIn: cuePoints.cueIn,
          cueOut: cuePoints.cueOut,
          mixDuration: mixDuration,
          technique: this.selectMixTechnique(trackA, trackB),
          harmonicScore: harmonicScore,
          tempoScore: tempoScore,
          confidence: (harmonicScore + tempoScore) / 2
        };
      }

      calculateHarmonicScore(trackA, trackB) {
        if (!trackA.camelotKey || !trackB.camelotKey) return 0.5;
        
        // Perfect match
        if (trackA.camelotKey === trackB.camelotKey) return 1;
        
        // Compatible keys
        if (trackA.compatibleKeys.includes(trackB.camelotKey)) return 0.9;
        
        // Energy boost mixing (up 2 semitones)
        const keyA = parseInt(trackA.camelotKey);
        const keyB = parseInt(trackB.camelotKey);
        if ((keyB - keyA + 12) % 12 === 2) return 0.8;
        
        // Not compatible
        return 0.3;
      }

      findCuePoints(trackA, trackB, currentPosition) {
        // Find next phrase boundary in track A
        const nextPhraseA = trackA.phrases.find(p => p.start > currentPosition);
        const cueOut = nextPhraseA ? nextPhraseA.start : currentPosition + 32000; // 32 bars
        
        // Find good entry point in track B (after intro)
        const introEnd = Math.max(trackB.introOutroBeats.intro, 16000); // At least 16 seconds
        const firstMainPhrase = trackB.phrases.find(p => p.type === 'main' && p.start >= introEnd);
        const cueIn = firstMainPhrase ? firstMainPhrase.start : introEnd;
        
        return { cueIn, cueOut };
      }

      calculateMixDuration(trackA, trackB) {
        // Base duration on tempo difference and energy levels
        const tempoDiff = Math.abs(trackA.tempo - trackB.tempo);
        const energyDiff = Math.abs(trackA.energy - trackB.energy);
        
        let duration = 16000; // Base 16 seconds
        
        // Longer mix for similar tempos
        if (tempoDiff < 5) duration += 8000;
        
        // Shorter mix for big energy jumps
        if (energyDiff > 0.5) duration -= 4000;
        
        return Math.max(8000, Math.min(32000, duration)); // 8-32 seconds
      }

      selectMixTechnique(trackA, trackB) {
        const tempoDiff = Math.abs(trackA.tempo - trackB.tempo);
        const energyDiff = Math.abs(trackA.energy - trackB.energy);
        
        if (tempoDiff < 2 && energyDiff < 0.2) {
          return 'blend'; // Long smooth blend
        } else if (energyDiff > 0.5) {
          return 'cut'; // Quick cut for energy changes
        } else if (trackB.energy > trackA.energy) {
          return 'build'; // Build up energy
        } else {
          return 'fade'; // Standard crossfade
        }
      }

      // Generate fallback when API fails
      generateFallbackAnalysis(trackId) {
        return {
          id: trackId,
          tempo: 128,
          camelotKey: '5A',
          compatibleKeys: ['4A', '6A', '5B'],
          energy: 0.7,
          danceability: 0.8,
          introOutroBeats: { intro: 0, outro: 180000 },
          phrases: this.generateDefaultPhrases(),
          beatGrid: this.generateBeatGrid(128, 180000)
        };
      }

      generateDefaultPhrases() {
        const phrases = [];
        for (let i = 0; i < 12; i++) {
          phrases.push({
            start: i * 16000,
            end: (i + 1) * 16000,
            type: i === 0 ? 'intro' : i === 11 ? 'outro' : 'main'
          });
        }
        return phrases;
      }

      // Real-time spectrum analysis
      getSpectrum() {
        if (!this.analyser) return new Array(32).fill(0);
        
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        this.analyser.getByteFrequencyData(dataArray);
        
        // Compress to 32 bands for visualization
        const bands = 32;
        const samplesPerBand = Math.floor(bufferLength / bands);
        const spectrum = [];
        
        for (let i = 0; i < bands; i++) {
          let sum = 0;
          for (let j = 0; j < samplesPerBand; j++) {
            sum += dataArray[i * samplesPerBand + j];
          }
          spectrum.push(sum / samplesPerBand / 255);
        }
        
        return spectrum;
      }

      // Auto-mix algorithm
      async performAutoMix(deckA, deckB, mixPoint) {
        const steps = 100; // Smoothness of transition
        const stepDuration = mixPoint.mixDuration / steps;
        
        for (let i = 0; i <= steps; i++) {
          const progress = i / steps;
          
          // Calculate crossfader position based on technique
          let faderPosition;
          switch (mixPoint.technique) {
            case 'blend':
              faderPosition = progress * 100;
              break;
            case 'cut':
              faderPosition = i < steps / 2 ? 0 : 100;
              break;
            case 'build':
              faderPosition = Math.pow(progress, 2) * 100; // Exponential curve
              break;
            default:
              faderPosition = progress * 100;
          }
          
          // Apply EQ automation
          this.automateEQ(progress, mixPoint.technique);
          
          // Update crossfader
          updateCrossfader(faderPosition);
          
          await new Promise(resolve => setTimeout(resolve, stepDuration));
        }
      }

      automateEQ(progress, technique) {
        if (technique === 'blend') {
          // Gradually swap bass frequencies
          const bassSwap = Math.sin(progress * Math.PI);
          // Deck A: reduce bass
          updateEQ('low', 'a', -bassSwap * 20);
          // Deck B: increase bass
          updateEQ('low', 'b', (1 - bassSwap) * 20);
        }
      }

      // Record mix for learning
      recordMix(trackA, trackB, mixPoint, success) {
        this.mixHistory.push({
          from: trackA.id,
          to: trackB.id,
          technique: mixPoint.technique,
          harmonicScore: mixPoint.harmonicScore,
          success: success,
          timestamp: Date.now()
        });
        
        // Update confidence based on success
        if (this.mixingTechniques[mixPoint.technique]) {
          const current = this.mixingTechniques[mixPoint.technique].confidence;
          this.mixingTechniques[mixPoint.technique].confidence = 
            current * 0.9 + (success ? 1 : 0) * 0.1;
        }
      }
    }

    // Initialize DJ AI
    djAI = new ProfessionalDJAI();

    // Spotify Authentication (same as before)
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function generateRandomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    async function login() {
      try {
        showStatus('Initializing DJ system...', 'connected');
        
        const state = generateRandomString(16);
        const codeVerifier = generateRandomString(128);
        const codeChallenge = await generateCodeChallenge(codeVerifier);
        
        sessionStorage.setItem('code_verifier', codeVerifier);
        sessionStorage.setItem('state', state);
        
        const authUrl = new URL('https://accounts.spotify.com/authorize');
        authUrl.searchParams.set('response_type', 'code');
        authUrl.searchParams.set('client_id', CLIENT_ID);
        authUrl.searchParams.set('scope', SCOPES.join(' '));
        authUrl.searchParams.set('redirect_uri', REDIRECT_URI);
        authUrl.searchParams.set('state', state);
        authUrl.searchParams.set('code_challenge_method', 'S256');
        authUrl.searchParams.set('code_challenge', codeChallenge);
        
        window.location = authUrl.toString();
      } catch (error) {
        showStatus('Login failed: ' + error.message, 'connected');
      }
    }

    async function handleRedirect() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');
      const error = params.get('error');

      if (error) {
        showStatus('Authentication failed', 'connected');
        return;
      }

      if (!code) return;

      try {
        showStatus('Loading DJ system...', 'connected');
        
        const storedState = sessionStorage.getItem('state');
        if (state !== storedState) {
          throw new Error('Invalid state');
        }

        const codeVerifier = sessionStorage.getItem('code_verifier');
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code,
            redirect_uri: REDIRECT_URI,
            client_id: CLIENT_ID,
            code_verifier: codeVerifier
          })
        });

        const data = await response.json();
        if (!data.access_token) {
          throw new Error('No access token');
        }

        accessToken = data.access_token;
        sessionStorage.setItem('access_token', data.access_token);
        
        window.history.replaceState({}, document.title, window.location.pathname);
        
        await initializeDJ();
        
      } catch (error) {
        showStatus('Setup failed', 'connected');
      }
    }

    // Spotify API wrapper
    async function spotifyRequest(endpoint, options = {}) {
      try {
        const response = await fetch(`https://api.spotify.com/v1${endpoint}`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json',
            ...options.headers
          },
          ...options
        });

        if (response.status === 204) return {};
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        return await response.json();
      } catch (error) {
        console.error('Spotify API error:', error);
        return null;
      }
    }

    // DJ Interface Functions
    async function initializeDJ() {
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('main-interface').style.display = 'block';
      
      showStatus('DJ System Ready', 'connected');
      
      // Load current track to Deck A
      const playback = await spotifyRequest('/me/player');
      if (playback && playback.item) {
        await loadToDeck('A', playback.item);
      }
      
      // Initialize visualizers
      initializeVisualizers();
      
      // Start monitoring
      setInterval(updateDJInterface, 1000);
    }

    async function loadToDeck(deck, track) {
      showLoading();
      
      const analysis = await djAI.analyzeForMixing(track.id);
      
      if (deck === 'A') {
        deckA.track = track;
        deckA.analysis = analysis;
        updateDeckDisplay('A', track, analysis);
      } else {
        deckB.track = track;
        deckB.analysis = analysis;
        updateDeckDisplay('B', track, analysis);
      }
      
      generateWaveform(deck);
      hideLoading();
    }

    function updateDeckDisplay(deck, track, analysis) {
      const prefix = deck === 'A' ? 'track-a' : 'track-b';
      document.getElementById(`${prefix}-name`).textContent = track.name;
      document.getElementById(`${prefix}-artist`).textContent = track.artists[0].name;
      document.getElementById(`bpm-${deck.toLowerCase()}`).textContent = 
        analysis ? analysis.tempo.toFixed(1) : '0.0';
      
      // Update sync status
      if (analysis && deckA.analysis && deckB.analysis) {
        const tempoMatch = Math.abs(deckA.analysis.tempo - deckB.analysis.tempo) < 1;
        document.getElementById(`sync-${deck.toLowerCase()}`).textContent = 
          tempoMatch ? 'SYNCED' : 'NOT SYNCED';
        document.getElementById(`sync-${deck.toLowerCase()}`).className = 
          tempoMatch ? 'sync-indicator synced' : 'sync-indicator';
      }
    }

    // Smart Mix Function
    async function smartMix() {
      if (mixInProgress || !deckA.track || !deckA.analysis) return;
      
      mixInProgress = true;
      showStatus('AI Mixing...', 'mixing');
      
      try {
        // Get current playback position
        const playback = await spotifyRequest('/me/player');
        const currentPosition = playback?.progress_ms || 0;
        
        // Load next track to Deck B if empty
        if (!deckB.track) {
          const queue = await spotifyRequest('/me/player/queue');
          if (queue?.queue?.length > 0) {
            await loadToDeck('B', queue.queue[0]);
          }
        }
        
        if (!deckB.track || !deckB.analysis) {
          throw new Error('No track in Deck B');
        }
        
        // Calculate mix point
        const mixPoint = await djAI.calculateMixPoint(
          deckA.analysis, 
          deckB.analysis, 
          currentPosition
        );
        
        // Update AI status
        document.getElementById('mix-quality').textContent = 
          mixPoint.confidence > 0.8 ? 'PRO' : 'GOOD';
        document.getElementById('beat-match').textContent = 
          Math.round(mixPoint.tempoScore * 100) + '%';
        document.getElementById('harmonic-mix').textContent = 
          mixPoint.harmonicScore > 0.8 ? 'ON' : 'OFF';
        
        // Start the mix
        if (autoMixActive) {
          await djAI.performAutoMix(deckA, deckB, mixPoint);
        } else {
          // Manual mix - just skip at the right point
          await spotifyRequest('/me/player/next', { method: 'POST' });
          
          // Wait for track change
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // Seek to cue point
          if (mixPoint.cueIn > 1000) {
            await spotifyRequest(`/me/player/seek?position_ms=${Math.floor(mixPoint.cueIn)}`, {
              method: 'PUT'
            });
          }
        }
        
        // Swap decks
        const tempDeck = deckA;
        deckA = deckB;
        deckB = { track: null, analysis: null, volume: 0, eq: { high: 0, mid: 0, low: 0 } };
        
        // Update display
        updateDeckDisplay('A', deckA.track, deckA.analysis);
        updateDeckDisplay('B', deckB.track || {name: 'Empty', artists: [{name: 'Load track'}]}, null);
        
        // Record success
        djAI.recordMix(tempDeck.analysis, deckA.analysis, mixPoint, true);
        
        showStatus('Mix Complete!', 'connected');
        
      } catch (error) {
        console.error('Mix failed:', error);
        showStatus('Mix failed - skipping normally', 'connected');
        await spotifyRequest('/me/player/next', { method: 'POST' });
      } finally {
        mixInProgress = false;
      }
    }

    // UI Control Functions
    function updateCrossfader(value) {
      crossfaderPosition = value;
      document.getElementById('crossfader').value = value;
      
      // Calculate volumes
      deckA.volume = value <= 50 ? 1 : 2 - (value / 50);
      deckB.volume = value >= 50 ? 1 : value / 50;
      
      // This would control actual audio in a real implementation
      console.log(`Deck A: ${Math.round(deckA.volume * 100)}%, Deck B: ${Math.round(deckB.volume * 100)}%`);
    }

    function updateEQ(band, deck, value) {
      if (deck === 'a') {
        deckA.eq[band] = value;
      } else {
        deckB.eq[band] = value;
      }
      // This would control actual EQ in a real implementation
    }

    function toggleAutoMix() {
      autoMixActive = !autoMixActive;
      const btn = document.getElementById('auto-mix-btn');
      btn.classList.toggle('active');
      document.getElementById('auto-mix').textContent = autoMixActive ? 'ON' : 'OFF';
    }

    function applyEffect(effect) {
      console.log(`Applying ${effect} effect`);
      // This would apply actual audio effects in a real implementation
    }

    async function loadNextTrack() {
      const queue = await spotifyRequest('/me/player/queue');
      if (queue?.queue?.length > 0) {
        await loadToDeck('B', queue.queue[0]);
      }
    }

    async function togglePlayPause() {
      const playback = await spotifyRequest('/me/player');
      if (playback?.is_playing) {
        await spotifyRequest('/me/player/pause', { method: 'PUT' });
      } else {
        await spotifyRequest('/me/player/play', { method: 'PUT' });
      }
    }

    // Visualization Functions
    function initializeVisualizers() {
      // Generate initial waveforms
      generateWaveform('A');
      generateWaveform('B');
      
      // Start spectrum analyzer
      setInterval(updateSpectrum, 50);
    }

    function generateWaveform(deck) {
      const container = document.getElementById(`waveform-${deck.toLowerCase()}`);
      container.innerHTML = '';
      
      // Generate random waveform for now
      for (let i = 0; i < 200; i++) {
        const bar = document.createElement('div');
        bar.className = 'waveform-bar';
        bar.style.height = Math.random() * 80 + 20 + 'px';
        container.appendChild(bar);
      }
    }

    function updateSpectrum() {
      const spectrum = djAI.getSpectrum();
      const container = document.getElementById('spectrum');
      
      if (container.children.length === 0) {
        // Create bars
        for (let i = 0; i < 32; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          container.appendChild(bar);
        }
      }
      
      // Update bar heights
      const bars = container.children;
      for (let i = 0; i < bars.length; i++) {
        bars[i].style.height = (spectrum[i] * 140 + 10) + 'px';
      }
    }

    async function updateDJInterface() {
      // Update playback progress
      const playback = await spotifyRequest('/me/player');
      if (playback && playback.item) {
        // Update waveform position
        const progress = playback.progress_ms / playback.item.duration_ms;
        const waveformA = document.getElementById('waveform-a');
        if (waveformA) {
          waveformA.style.transform = `translateX(${-progress * 100}%)`;
        }
      }
    }

    // Utility Functions
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type}`;
    }

    function showLoading() {
      document.getElementById('loading-overlay').classList.add('active');
    }

    function hideLoading() {
      document.getElementById('loading-overlay').classList.remove('active');
    }

    function logout() {
      accessToken = null;
      sessionStorage.clear();
      window.location.reload();
    }

    // Initialize on load
    window.onload = async function() {
      const storedToken = sessionStorage.getItem('access_token');
      if (storedToken) {
        accessToken = storedToken;
        await initializeDJ();
      } else {
        await handleRedirect();
      }
    };

    // Crossfader event listener
    document.getElementById('crossfader')?.addEventListener('input', (e) => {
      updateCrossfader(e.target.value);
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (!accessToken) return;
      
      switch(e.code) {
        case 'Space':
          e.preventDefault();
          togglePlayPause();
          break;
        case 'KeyM':
          e.preventDefault();
          smartMix();
          break;
        case 'KeyA':
          e.preventDefault();
          toggleAutoMix();
          break;
      }
    });
  </script>
</body>
</html>

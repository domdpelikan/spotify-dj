<!DOCTYPE html>
<html>
<head>
  <title>Smart Beat Skip - Spotify AI</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1db954, #191414);
      color: white;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      text-align: center;
    }

    .header h1 {
      font-size: 3em;
      margin-bottom: 10px;
      background: linear-gradient(45deg, #1db954, #ff6b35);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      font-size: 1.2em;
      opacity: 0.8;
      margin-bottom: 30px;
    }

    .status {
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      font-weight: bold;
      font-size: 1.1em;
    }

    .status.connected {
      background: rgba(29, 185, 84, 0.2);
      border: 2px solid #1db954;
    }

    .status.disconnected {
      background: rgba(255, 0, 0, 0.2);
      border: 2px solid #ff4444;
    }

    .status.working {
      background: rgba(255, 165, 0, 0.2);
      border: 2px solid #ffa500;
    }

    .login-section {
      padding: 40px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    .main-interface {
      display: none;
      padding: 40px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    .current-track {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
    }

    .track-name {
      font-size: 1.5em;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .track-artist {
      font-size: 1.1em;
      opacity: 0.8;
      margin-bottom: 10px;
    }

    .track-progress {
      font-size: 0.9em;
      opacity: 0.7;
    }

    .controls {
      margin: 30px 0;
    }

    .btn {
      padding: 15px 30px;
      font-size: 1.2em;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      margin: 10px;
      min-width: 150px;
    }

    .btn-primary {
      background: linear-gradient(45deg, #1db954, #1ed760);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(29, 185, 84, 0.4);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.15);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.25);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .ai-status {
      background: rgba(138, 43, 226, 0.2);
      border: 2px solid rgba(138, 43, 226, 0.5);
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
    }

    .ai-learning {
      font-size: 1.1em;
      margin-bottom: 10px;
    }

    .beat-info {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
      text-align: center;
    }

    .beat-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 8px;
      min-width: 120px;
    }

    .beat-number {
      font-size: 2em;
      font-weight: bold;
      color: #1db954;
    }

    .beat-label {
      font-size: 0.9em;
      opacity: 0.8;
    }

    .instructions {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      font-size: 0.95em;
      line-height: 1.5;
    }

    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid transparent;
      border-top: 2px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .beat-visualizer {
      height: 60px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      margin: 15px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
      position: relative;
      overflow: hidden;
    }

    .beat-bar {
      width: 4px;
      height: 40px;
      background: #1db954;
      margin: 0 2px;
      animation: pulse 0.5s ease-in-out infinite;
      opacity: 0.7;
    }

    @keyframes pulse {
      0% { transform: scaleY(0.5); }
      50% { transform: scaleY(1); }
      100% { transform: scaleY(0.5); }
    }

    .sync-indicator {
      position: absolute;
      top: 5px;
      right: 10px;
      font-size: 0.8em;
      padding: 4px 8px;
      background: rgba(29, 185, 84, 0.3);
      border-radius: 4px;
    }

    .performance-stats {
      background: rgba(0, 0, 0, 0.2);
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      font-size: 0.8em;
      opacity: 0.7;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2.5em;
      }
      
      .btn {
        padding: 12px 25px;
        font-size: 1.1em;
        min-width: 130px;
      }

      .beat-info {
        flex-direction: column;
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üéµ Smart Beat Skip</h1>
      <p class="subtitle">Ultra-fast AI beat synchronization for Spotify</p>
    </div>

    <div id="status" class="status disconnected">Not Connected</div>

    <div id="login-section" class="login-section">
      <h2 style="margin-bottom: 20px;">üéß Intelligent Music Skipping</h2>
      <p style="margin-bottom: 25px; line-height: 1.5;">
        Skip songs intelligently! When you press skip (here or in Spotify), 
        the AI automatically finds the perfect beat in the next song to match 
        where you left off. No more jarring transitions to silence.
      </p>
      <button onclick="login()" class="btn btn-primary">üîê Connect to Spotify</button>
      <p style="margin-top: 15px; font-size: 0.9em; opacity: 0.7;">
        Requires Spotify Premium
      </p>
    </div>

    <div id="main-interface" class="main-interface">
      <div class="current-track">
        <div class="track-name" id="track-name">No Track Playing</div>
        <div class="track-artist" id="track-artist">Start music in Spotify</div>
        <div class="track-progress" id="track-progress">0:00 / 0:00</div>
        
        <div class="beat-visualizer" id="beat-visualizer">
          <div class="beat-bar" style="animation-delay: 0s;"></div>
          <div class="beat-bar" style="animation-delay: 0.1s;"></div>
          <div class="beat-bar" style="animation-delay: 0.2s;"></div>
          <div class="beat-bar" style="animation-delay: 0.3s;"></div>
          <div class="beat-bar" style="animation-delay: 0.4s;"></div>
          <div class="sync-indicator" id="sync-indicator">SYNCED</div>
        </div>
      </div>

      <div class="beat-info">
        <div class="beat-item">
          <div class="beat-number" id="current-bpm">--</div>
          <div class="beat-label">BPM</div>
        </div>
        <div class="beat-item">
          <div class="beat-number" id="sync-quality">--</div>
          <div class="beat-label">Sync Quality</div>
        </div>
        <div class="beat-item">
          <div class="beat-number" id="skip-count">0</div>
          <div class="beat-label">Smart Skips</div>
        </div>
      </div>

      <div class="beat-item">
        <div class="beat-number" id="avg-delay">--</div>
        <div class="beat-label">Avg Delay (ms)</div>
      </div>

      <div class="controls">
        <button onclick="smartSkip()" class="btn btn-primary" id="skip-btn">
          ‚ö° Instant Skip
        </button>
        <button onclick="togglePlayPause()" class="btn btn-secondary" id="play-btn">
          ‚ñ∂Ô∏è Play
        </button>
      </div>

      <div class="ai-status">
        <div class="ai-learning" id="ai-status">ü§ñ AI Active: Ultra-fast beat matching enabled</div>
        <div id="ai-message">Predictive sync engine ready</div>
      </div>

      <div class="performance-stats" id="performance-stats">
        Last sync: -- ms | Cache hits: 0 | Predictions: 0
      </div>

      <div class="instructions">
        <strong>How it works:</strong><br>
        ‚Ä¢ Play music in Spotify normally<br>
        ‚Ä¢ Press "Instant Skip" here OR use Spotify's skip button<br>
        ‚Ä¢ AI predicts and pre-calculates sync points for seamless transitions<br>
        ‚Ä¢ Ultra-fast seek operations minimize transition time to &lt;100ms!
      </div>

      <button onclick="logout()" class="btn btn-secondary" style="margin-top: 20px;">
        üö™ Disconnect
      </button>
    </div>
  </div>

  <script>
    // Configuration
    const CLIENT_ID = 'e60ede83721246198bf4fe8a9bee8ca8';
    const REDIRECT_URI = window.location.origin + window.location.pathname;
    const SCOPES = [
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-currently-playing',
      'user-read-playback-position',
      'streaming'
    ];

    // Global state
    let accessToken = null;
    let currentTrack = null;
    let skipCount = 0;
    let updateInterval = null;
    let isProcessing = false;
    let lastTrackId = null;
    let lastPosition = 0;
    let manualSkipInProgress = false;
    let beatDetector = null;
    let syncDelays = [];
    let predictiveCache = new Map();

    // Ultra-fast Beat Detection System with Predictive Caching
    class UltraFastBeatDetector {
      constructor() {
        this.trackCache = new Map();
        this.successRate = [];
        this.audioContext = null;
        this.lastBeatTime = 0;
        this.beatInterval = 500;
        this.queuePredictions = new Map();
        this.cacheHits = 0;
        this.predictions = 0;
      }

      async initAudioContext() {
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
      }

      // Batch fetch track features for entire queue
      async batchFetchFeatures(trackIds) {
        const uncachedIds = trackIds.filter(id => !this.trackCache.has(id));
        if (uncachedIds.length === 0) return;

        try {
          // Fetch up to 100 tracks at once using batch API
          const chunks = [];
          for (let i = 0; i < uncachedIds.length; i += 100) {
            chunks.push(uncachedIds.slice(i, i + 100));
          }

          for (const chunk of chunks) {
            const ids = chunk.join(',');
            const features = await spotifyRequest(`/audio-features?ids=${ids}`);
            
            if (features && features.audio_features) {
              features.audio_features.forEach((feature, index) => {
                if (feature) {
                  this.trackCache.set(chunk[index], {
                    tempo: feature.tempo || 120,
                    energy: feature.energy || 0.5,
                    danceability: feature.danceability || 0.5,
                    time_signature: feature.time_signature || 4,
                    key: feature.key,
                    mode: feature.mode,
                    duration_ms: feature.duration_ms
                  });
                }
              });
            }
          }
        } catch (error) {
          console.error('Batch fetch failed:', error);
        }
      }

      // Predictive sync calculation for entire queue
      async predictQueueSyncs(currentTrackId, currentPosition, queueTracks) {
        const currentFeatures = await this.getTrackFeatures(currentTrackId);
        if (!currentFeatures) return;

        this.predictions++;
        
        // Pre-calculate sync points for next 5 tracks
        for (let i = 0; i < Math.min(5, queueTracks.length); i++) {
          const track = queueTracks[i];
          const features = await this.getTrackFeatures(track.id);
          
          if (features) {
            const syncData = await this.findSyncPoint(currentFeatures, features, currentPosition);
            this.queuePredictions.set(track.id, {
              ...syncData,
              timestamp: Date.now()
            });
          }
        }

        this.updatePerformanceStats();
      }

      async getTrackFeatures(trackId) {
        if (this.trackCache.has(trackId)) {
          this.cacheHits++;
          return this.trackCache.get(trackId);
        }

        try {
          const features = await spotifyRequest(`/audio-features/${trackId}`);
          if (features) {
            const trackData = {
              tempo: features.tempo || 120,
              energy: features.energy || 0.5,
              danceability: features.danceability || 0.5,
              time_signature: features.time_signature || 4,
              key: features.key,
              mode: features.mode,
              duration_ms: features.duration_ms
            };
            this.trackCache.set(trackId, trackData);
            return trackData;
          }
        } catch (error) {
          console.log('Audio features not available, using fallback detection');
        }

        return this.estimateTrackFeatures(trackId);
      }

      async estimateTrackFeatures(trackId) {
        const track = await spotifyRequest(`/tracks/${trackId}`);
        if (!track) return null;

        let estimatedBPM = 120;
        
        const fullText = `${track.name} ${track.artists.map(a => a.name).join(' ')}`.toLowerCase();
        
        if (fullText.includes('ballad') || fullText.includes('slow')) {
          estimatedBPM = 70;
        } else if (fullText.includes('dance') || fullText.includes('club')) {
          estimatedBPM = 128;
        } else if (fullText.includes('rock') || fullText.includes('metal')) {
          estimatedBPM = 140;
        } else if (fullText.includes('jazz')) {
          estimatedBPM = 110;
        }

        const features = {
          tempo: estimatedBPM,
          energy: 0.5,
          danceability: 0.5,
          time_signature: 4,
          duration_ms: track.duration_ms
        };

        this.trackCache.set(trackId, features);
        return features;
      }

      calculateBeatPosition(features, progressMs) {
        if (!features) return { beat: 0, measureBeat: 0 };

        const msPerBeat = 60000 / features.tempo;
        const beatNumber = Math.floor(progressMs / msPerBeat);
        const measureBeat = beatNumber % features.time_signature;

        return {
          beat: beatNumber,
          measureBeat: measureBeat,
          nextBeatMs: (beatNumber + 1) * msPerBeat,
          msPerBeat: msPerBeat
        };
      }

      async findSyncPoint(sourceFeatures, targetFeatures, sourceProgress) {
        if (!sourceFeatures || !targetFeatures) {
          return { position: 0, confidence: 50 };
        }

        const sourceBeat = this.calculateBeatPosition(sourceFeatures, sourceProgress);
        const sourceRelativePos = sourceProgress / sourceFeatures.duration_ms;
        
        // Improved algorithm for better sync points
        let targetPosition = sourceRelativePos * targetFeatures.duration_ms;
        
        // Find the closest strong beat (downbeat) for better musical alignment
        const targetBeat = this.calculateBeatPosition(targetFeatures, targetPosition);
        const nextDownbeat = Math.ceil(targetBeat.beat / targetFeatures.time_signature) * targetFeatures.time_signature;
        const downbeatPosition = nextDownbeat * targetBeat.msPerBeat;
        
        // Choose between relative position and downbeat based on track structure
        if (sourceRelativePos > 0.2 && sourceRelativePos < 0.8) {
          // Use downbeat for middle sections
          targetPosition = Math.min(downbeatPosition, targetFeatures.duration_ms * 0.9);
        }
        
        let confidence = 70;
        
        const tempoRatio = Math.min(sourceFeatures.tempo, targetFeatures.tempo) / 
                          Math.max(sourceFeatures.tempo, targetFeatures.tempo);
        confidence += tempoRatio * 25;
        
        const energyDiff = Math.abs(sourceFeatures.energy - targetFeatures.energy);
        confidence += (1 - energyDiff) * 15;
        
        // Key compatibility bonus
        if (sourceFeatures.key === targetFeatures.key) {
          confidence += 10;
        }

        if (sourceRelativePos > 0.1 && sourceRelativePos < 0.9) {
          confidence = Math.min(100, confidence);
        } else {
          confidence = Math.max(50, confidence - 20);
        }

        return {
          position: Math.max(0, targetPosition),
          confidence: Math.round(confidence),
          targetBeat: targetBeat.beat,
          tempo: targetFeatures.tempo,
          isDownbeat: targetPosition === downbeatPosition
        };
      }

      recordSuccess(confidence) {
        this.successRate.push(confidence);
        if (this.successRate.length > 50) {
          this.successRate.shift();
        }
      }

      getAverageSuccess() {
        if (this.successRate.length === 0) return 85;
        const sum = this.successRate.reduce((a, b) => a + b, 0);
        return Math.round(sum / this.successRate.length);
      }

      updatePerformanceStats() {
        const avgDelay = syncDelays.length ? 
          Math.round(syncDelays.reduce((a, b) => a + b, 0) / syncDelays.length) : 0;
        
        document.getElementById('performance-stats').textContent = 
          `Last sync: ${syncDelays[syncDelays.length - 1] || '--'} ms | Cache hits: ${this.cacheHits} | Predictions: ${this.predictions}`;
        
        document.getElementById('avg-delay').textContent = avgDelay || '--';
      }
    }

    beatDetector = new UltraFastBeatDetector();

    // Authentication functions
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function generateRandomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    async function login() {
      try {
        showStatus('Connecting to Spotify...', 'working');
        
        const state = generateRandomString(16);
        const codeVerifier = generateRandomString(128);
        const codeChallenge = await generateCodeChallenge(codeVerifier);
        
        sessionStorage.setItem('code_verifier', codeVerifier);
        sessionStorage.setItem('state', state);
        
        const authUrl = new URL('https://accounts.spotify.com/authorize');
        authUrl.searchParams.set('response_type', 'code');
        authUrl.searchParams.set('client_id', CLIENT_ID);
        authUrl.searchParams.set('scope', SCOPES.join(' '));
        authUrl.searchParams.set('redirect_uri', REDIRECT_URI);
        authUrl.searchParams.set('state', state);
        authUrl.searchParams.set('code_challenge_method', 'S256');
        authUrl.searchParams.set('code_challenge', codeChallenge);
        
        window.location = authUrl.toString();
      } catch (error) {
        showStatus('Login failed: ' + error.message, 'disconnected');
      }
    }

    async function handleRedirect() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');
      const error = params.get('error');

      if (error) {
        showStatus('Authentication failed: ' + error, 'disconnected');
        return;
      }

      if (!code) return;

      try {
        showStatus('Completing authentication...', 'working');
        
        const storedState = sessionStorage.getItem('state');
        if (state !== storedState) {
          throw new Error('Invalid state parameter');
        }

        const codeVerifier = sessionStorage.getItem('code_verifier');
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code,
            redirect_uri: REDIRECT_URI,
            client_id: CLIENT_ID,
            code_verifier: codeVerifier
          })
        });

        const data = await response.json();
        if (!data.access_token) {
          throw new Error('No access token received');
        }

        accessToken = data.access_token;
        sessionStorage.setItem('access_token', data.access_token);
        
        window.history.replaceState({}, document.title, window.location.pathname);
        sessionStorage.removeItem('code_verifier');
        sessionStorage.removeItem('state');
        
        await initializeApp();
        
      } catch (error) {
        showStatus('Authentication failed: ' + error.message, 'disconnected');
      }
    }

    // Spotify API functions with retry logic
    async function spotifyRequest(endpoint, options = {}, retries = 2) {
      for (let i = 0; i <= retries; i++) {
        try {
          const response = await fetch(`https://api.spotify.com/v1${endpoint}`, {
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json',
              ...options.headers
            },
            ...options
          });

          if (response.status === 204) return {};
          
          if (!response.ok) {
            if (response.status === 401) {
              sessionStorage.removeItem('access_token');
              window.location.reload();
            }
            
            if (i < retries && response.status >= 500) {
              await new Promise(resolve => setTimeout(resolve, 100 * (i + 1)));
              continue;
            }
            
            throw new Error(`HTTP ${response.status}`);
          }
          
          return await response.json();
        } catch (error) {
          if (i === retries) {
            console.error('Spotify API error:', error);
            return null;
          }
          await new Promise(resolve => setTimeout(resolve, 50 * (i + 1)));
        }
      }
    }

    async function getCurrentPlayback() {
      return await spotifyRequest('/me/player');
    }

    async function getUserQueue() {
      return await spotifyRequest('/me/player/queue');
    }

    // Ultra-fast Smart Skip implementation
    async function smartSkip() {
      if (isProcessing) return;

      if (!currentTrack) {
        showStatus('No track playing - start music in Spotify', 'disconnected');
        return;
      }

      const skipStartTime = performance.now();

      try {
        isProcessing = true;
        manualSkipInProgress = true;
        document.getElementById('skip-btn').disabled = true;

        // Get current state immediately
        const [playbackState, queue] = await Promise.all([
          getCurrentPlayback(),
          getUserQueue()
        ]);

        if (!playbackState || !queue?.queue?.length) {
          throw new Error('Could not get playback state or queue');
        }

        const currentPosition = playbackState.progress_ms;
        const nextTrack = queue.queue[0];
        
        // Check if we have a pre-calculated sync point
        let syncData = beatDetector.queuePredictions.get(nextTrack.id);
        
        if (!syncData || Date.now() - syncData.timestamp > 10000) {
          // Calculate sync point if not cached or stale
          const [currentFeatures, nextFeatures] = await Promise.all([
            beatDetector.getTrackFeatures(playbackState.item.id),
            beatDetector.getTrackFeatures(nextTrack.id)
          ]);
          
          syncData = await beatDetector.findSyncPoint(
            currentFeatures, 
            nextFeatures, 
            currentPosition
          );
        }

        // Immediate skip - no waiting
        const skipPromise = spotifyRequest('/me/player/next', { method: 'POST' });
        
        // Prepare seek command while skip is happening
        const seekPosition = Math.max(0, Math.floor(syncData.position));
        
        // Wait for skip to complete
        await skipPromise;
        
        // Ultra-aggressive seek timing
        let seekApplied = false;
        const maxAttempts = 8;
        const seekInterval = 50; // Check every 50ms
        
        for (let attempt = 0; attempt < maxAttempts && !seekApplied; attempt++) {
          await new Promise(resolve => setTimeout(resolve, seekInterval));
          
          const state = await getCurrentPlayback();
          if (state?.item?.id === nextTrack.id) {
            // Track changed - apply seek immediately
            if (seekPosition > 1000) {
              // Use Promise.allSettled to fire multiple requests simultaneously
              await Promise.allSettled([
                spotifyRequest(`/me/player/seek?position_ms=${seekPosition}`, { method: 'PUT' }),
                // Backup request in case first fails
                new Promise(resolve => setTimeout(() => {
                  spotifyRequest(`/me/player/seek?position_ms=${seekPosition}`, { method: 'PUT' })
                    .then(resolve).catch(resolve);
                }, 20))
              ]);
            }
            seekApplied = true;
            break;
          }
        }

        const totalTime = Math.round(performance.now() - skipStartTime);
        syncDelays.push(totalTime);
        if (syncDelays.length > 20) syncDelays.shift();

        beatDetector.recordSuccess(syncData.confidence);
        skipCount++;
        
        showStatus(`‚ö° Instant sync in ${totalTime}ms!`, 'connected');
        updateStats();

        // Update UI immediately
        if (nextFeatures) {
          document.getElementById('current-bpm').textContent = Math.round(nextFeatures.tempo);
        }

        // Visual feedback
        document.getElementById('sync-indicator').textContent = seekApplied ? 'BEAT MATCHED' : 'SYNCED';
        document.getElementById('sync-indicator').style.background = 'rgba(29, 185, 84, 0.5)';
        
        setTimeout(() => {
          document.getElementById('sync-indicator').textContent = 'SYNCED';
          document.getElementById('sync-indicator').style.background = 'rgba(29, 185, 84, 0.3)';
        }, 1500);

      } catch (error) {
        console.error('Smart skip error:', error);
        
        // Fallback: simple skip
        await spotifyRequest('/me/player/next', { method: 'POST' });
        const fallbackTime = Math.round(performance.now() - skipStartTime);
        syncDelays.push(fallbackTime);
        skipCount++;
        updateStats();
        
        showStatus(`‚úÖ Skip completed in ${fallbackTime}ms`, 'connected');
      } finally {
        isProcessing = false;
        document.getElementById('skip-btn').disabled = false;
        setTimeout(() => {
          manualSkipInProgress = false;
        }, 2000);
        
        beatDetector.updatePerformanceStats();
      }
    }

    // Enhanced external skip detection
    async function handleExternalSkip(oldTrackId, newTrackId, lastKnownPosition) {
      if (manualSkipInProgress || isProcessing) return;

      const skipStartTime = performance.now();

      try {
        // Check for pre-calculated sync point
        let syncData = beatDetector.queuePredictions.get(newTrackId);
        
        if (!syncData) {
          // Quick calculation for external skips
          const [oldFeatures, newFeatures] = await Promise.all([
            beatDetector.getTrackFeatures(oldTrackId),
            beatDetector.getTrackFeatures(newTrackId)
          ]);
          
          if (oldFeatures && newFeatures) {
            syncData = await beatDetector.findSyncPoint(
              oldFeatures, 
              newFeatures, 
              lastKnownPosition
            );
          }
        }
        
        if (syncData && syncData.position > 1000) {
          // Apply ultra-fast seek
          const seekPosition = Math.floor(syncData.position);
          
          // Multiple rapid attempts for fastest possible sync
          await Promise.allSettled([
            spotifyRequest(`/me/player/seek?position_ms=${seekPosition}`, { method: 'PUT' }),
            new Promise(resolve => setTimeout(() => {
              spotifyRequest(`/me/player/seek?position_ms=${seekPosition}`, { method: 'PUT' })
                .then(resolve).catch(resolve);
            }, 30))
          ]);
          
          const totalTime = Math.round(performance.now() - skipStartTime);
          syncDelays.push(totalTime);
          if (syncDelays.length > 20) syncDelays.shift();
          
          beatDetector.recordSuccess(syncData.confidence);
          skipCount++;
          updateStats();
          
          showStatus(`üéØ Auto-synced in ${totalTime}ms!`, 'connected');
          
          // Update BPM display
          const newFeatures = await beatDetector.getTrackFeatures(newTrackId);
          if (newFeatures) {
            document.getElementById('current-bpm').textContent = Math.round(newFeatures.tempo);
          }
        }
        
      } catch (error) {
        console.error('External skip sync failed:', error);
        showStatus('‚úÖ Skip detected', 'connected');
      }
      
      beatDetector.updatePerformanceStats();
    }

    // Enhanced playback monitoring with predictive caching
    async function updatePlaybackInfo() {
      try {
        const playbackState = await getCurrentPlayback();
        
        if (!playbackState || !playbackState.item) {
          document.getElementById('track-name').textContent = 'No Track Playing';
          document.getElementById('track-artist').textContent = 'Start music in Spotify';
          document.getElementById('track-progress').textContent = '0:00 / 0:00';
          document.getElementById('play-btn').innerHTML = '‚ñ∂Ô∏è Play';
          document.getElementById('current-bpm').textContent = '--';
          lastTrackId = null;
          return;
        }

        const track = playbackState.item;
        
        // Update track info
        document.getElementById('track-name').textContent = track.name;
        document.getElementById('track-artist').textContent = track.artists.map(a => a.name).join(', ');
        document.getElementById('track-progress').textContent = 
          `${formatTime(playbackState.progress_ms)} / ${formatTime(track.duration_ms)}`;
        document.getElementById('play-btn').innerHTML = playbackState.is_playing ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';

        // Detect track changes (external skips)
        if (lastTrackId && lastTrackId !== track.id && !manualSkipInProgress) {
          console.log(`External skip detected: ${lastTrackId} -> ${track.id}`);
          handleExternalSkip(lastTrackId, track.id, lastPosition);
        }

        // Update tracking variables
        lastTrackId = track.id;
        lastPosition = playbackState.progress_ms;

        // Predictive queue analysis every 10 seconds or on track change
        if (!currentTrack || currentTrack.id !== track.id || 
            (Date.now() - (beatDetector.lastQueueUpdate || 0)) > 10000) {
          
          currentTrack = track;
          beatDetector.lastQueueUpdate = Date.now();
          
          // Get queue and pre-calculate sync points
          const queue = await getUserQueue();
          if (queue?.queue?.length) {
            // Batch fetch features for efficiency
            const queueIds = queue.queue.slice(0, 10).map(t => t.id);
            await beatDetector.batchFetchFeatures([track.id, ...queueIds]);
            
            // Predict sync points for upcoming tracks
            await beatDetector.predictQueueSyncs(track.id, playbackState.progress_ms, queue.queue);
          }
          
          // Get and display current track BPM
          const features = await beatDetector.getTrackFeatures(track.id);
          if (features) {
            document.getElementById('current-bpm').textContent = Math.round(features.tempo);
            updateAIStatus(`Track analyzed: ${Math.round(features.tempo)} BPM, ${queue?.queue?.length || 0} tracks cached`);
          }
        }

        // Update beat visualizer
        updateBeatVisualizer(playbackState.is_playing);

      } catch (error) {
        console.error('Update failed:', error);
      }
    }

    async function togglePlayPause() {
      try {
        const playbackState = await getCurrentPlayback();
        if (!playbackState) return;
        
        if (playbackState.is_playing) {
          await spotifyRequest('/me/player/pause', { method: 'PUT' });
        } else {
          await spotifyRequest('/me/player/play', { method: 'PUT' });
        }
      } catch (error) {
        showStatus('Playback control failed', 'disconnected');
      }
    }

    // UI Update functions
    function updateStats() {
      document.getElementById('skip-count').textContent = skipCount;
      const avgSuccess = beatDetector.getAverageSuccess();
      document.getElementById('sync-quality').textContent = avgSuccess + '%';
      
      beatDetector.updatePerformanceStats();
    }

    function updateAIStatus(message) {
      document.getElementById('ai-message').textContent = message;
    }

    function updateBeatVisualizer(isPlaying) {
      const bars = document.querySelectorAll('.beat-bar');
      bars.forEach(bar => {
        bar.style.animationPlayState = isPlaying ? 'running' : 'paused';
      });
    }

    // Utility functions
    function formatTime(ms) {
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type}`;
    }

    async function initializeApp() {
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('main-interface').style.display = 'block';
      
      showStatus('‚ö° Ultra-fast Smart Beat Skip ready!', 'connected');
      updateAIStatus('Predictive sync engine active - analyzing queue...');
      
      // Initialize audio context
      await beatDetector.initAudioContext();
      
      // Start high-frequency monitoring for fastest response
      updateInterval = setInterval(updatePlaybackInfo, 500); // 500ms for responsive caching
      await updatePlaybackInfo();
      
      // Set initial stats
      updateStats();
      
      // Initial queue analysis
      setTimeout(async () => {
        const queue = await getUserQueue();
        if (queue?.queue?.length) {
          const queueIds = queue.queue.slice(0, 15).map(t => t.id);
          await beatDetector.batchFetchFeatures(queueIds);
          updateAIStatus(`Ready! ${queueIds.length} tracks analyzed and cached.`);
        }
      }, 1000);
    }

    function logout() {
      if (updateInterval) clearInterval(updateInterval);
      accessToken = null;
      sessionStorage.clear();
      
      document.getElementById('login-section').style.display = 'block';
      document.getElementById('main-interface').style.display = 'none';
      showStatus('Disconnected', 'disconnected');
      
      // Reset state
      currentTrack = null;
      skipCount = 0;
      lastTrackId = null;
      lastPosition = 0;
      syncDelays = [];
      predictiveCache.clear();
      beatDetector = new UltraFastBeatDetector();
    }

    // Initialize on load
    window.onload = async function() {
      showStatus('Loading Ultra-fast Smart Beat Skip...', 'working');
      
      const storedToken = sessionStorage.getItem('access_token');
      if (storedToken) {
        accessToken = storedToken;
        await initializeApp();
      } else {
        await handleRedirect();
      }
      
      if (!accessToken) {
        showStatus('Connect to Spotify to begin', 'disconnected');
      }
    };

    // Enhanced keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (!accessToken) return;
      
      if (e.code === 'Space' && e.target.tagName !== 'BUTTON') {
        e.preventDefault();
        togglePlayPause();
      } else if (e.code === 'ArrowRight') {
        e.preventDefault();
        smartSkip();
      } else if (e.code === 'KeyS' && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        smartSkip();
      }
    });

    // Performance monitoring
    setInterval(() => {
      if (beatDetector) {
        beatDetector.updatePerformanceStats();
      }
    }, 2000);
  </script>
</body>
</html>

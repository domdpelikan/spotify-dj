<!DOCTYPE html>
<html>
<head>
  <title>Smart Beat Skip - Spotify AI</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1db954, #191414);
      color: white;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      text-align: center;
    }

    .header h1 {
      font-size: 3em;
      margin-bottom: 10px;
      background: linear-gradient(45deg, #1db954, #ff6b35);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      font-size: 1.2em;
      opacity: 0.8;
      margin-bottom: 30px;
    }

    .status {
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      font-weight: bold;
      font-size: 1.1em;
    }

    .status.connected {
      background: rgba(29, 185, 84, 0.2);
      border: 2px solid #1db954;
    }

    .status.disconnected {
      background: rgba(255, 0, 0, 0.2);
      border: 2px solid #ff4444;
    }

    .status.working {
      background: rgba(255, 165, 0, 0.2);
      border: 2px solid #ffa500;
    }

    .login-section {
      padding: 40px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    .main-interface {
      display: none;
      padding: 40px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    .current-track {
      background: rgba(0, 0, 0, 0.3);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
    }

    .track-name {
      font-size: 1.5em;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .track-artist {
      font-size: 1.1em;
      opacity: 0.8;
      margin-bottom: 10px;
    }

    .track-progress {
      font-size: 0.9em;
      opacity: 0.7;
    }

    .controls {
      margin: 30px 0;
    }

    .btn {
      padding: 15px 30px;
      font-size: 1.2em;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      margin: 10px;
      min-width: 150px;
    }

    .btn-primary {
      background: linear-gradient(45deg, #1db954, #1ed760);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(29, 185, 84, 0.4);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.15);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.25);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .ai-status {
      background: rgba(138, 43, 226, 0.2);
      border: 2px solid rgba(138, 43, 226, 0.5);
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
    }

    .ai-learning {
      font-size: 1.1em;
      margin-bottom: 10px;
    }

    .beat-info {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
      text-align: center;
    }

    .beat-item {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 8px;
      min-width: 120px;
    }

    .beat-number {
      font-size: 2em;
      font-weight: bold;
      color: #1db954;
    }

    .beat-label {
      font-size: 0.9em;
      opacity: 0.8;
    }

    .instructions {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      font-size: 0.95em;
      line-height: 1.5;
    }

    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid transparent;
      border-top: 2px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .success-indicator {
      color: #1db954;
      font-weight: bold;
    }

    .error-indicator {
      color: #ff4444;
      font-weight: bold;
    }

    .external-skip-indicator {
      background: rgba(255, 165, 0, 0.2);
      border: 2px solid #ffa500;
      padding: 10px;
      border-radius: 8px;
      margin: 10px 0;
      font-size: 0.9em;
      display: none;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2.5em;
      }
      
      .btn {
        padding: 12px 25px;
        font-size: 1.1em;
        min-width: 130px;
      }

      .beat-info {
        flex-direction: column;
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üéµ Smart Beat Skip</h1>
      <p class="subtitle">AI-powered beat synchronization for Spotify</p>
    </div>

    <div id="status" class="status disconnected">Not Connected</div>

    <div id="login-section" class="login-section">
      <h2 style="margin-bottom: 20px;">üéß Intelligent Music Skipping</h2>
      <p style="margin-bottom: 25px; line-height: 1.5;">
        Skip songs intelligently! When you press skip (here or in Spotify), 
        the AI automatically finds the perfect beat in the next song to match 
        where you left off. No more jarring transitions to silence.
      </p>
      <button onclick="login()" class="btn btn-primary">üîê Connect to Spotify</button>
      <p style="margin-top: 15px; font-size: 0.9em; opacity: 0.7;">
        Requires Spotify Premium
      </p>
    </div>

    <div id="main-interface" class="main-interface">
      <div class="current-track">
        <div class="track-name" id="track-name">No Track Playing</div>
        <div class="track-artist" id="track-artist">Start music in Spotify</div>
        <div class="track-progress" id="track-progress">0:00 / 0:00</div>
      </div>

      <div id="external-skip-indicator" class="external-skip-indicator">
        üéØ Detected external skip - applying smart beat sync...
      </div>

      <div class="beat-info">
        <div class="beat-item">
          <div class="beat-number" id="current-beat">--</div>
          <div class="beat-label">Current Beat</div>
        </div>
        <div class="beat-item">
          <div class="beat-number" id="sync-confidence">--</div>
          <div class="beat-label">Sync Quality</div>
        </div>
        <div class="beat-item">
          <div class="beat-number" id="skip-count">0</div>
          <div class="beat-label">Smart Skips</div>
        </div>
      </div>

      <div class="controls">
        <button onclick="smartSkip()" class="btn btn-primary" id="skip-btn">
          üéØ Smart Skip
        </button>
        <button onclick="togglePlayPause()" class="btn btn-secondary" id="play-btn">
          ‚ñ∂Ô∏è Play
        </button>
      </div>

      <div class="ai-status">
        <div class="ai-learning" id="ai-status">ü§ñ AI Learning: Analyzing beat patterns...</div>
        <div id="ai-message">The AI is training to understand your music and find perfect skip points.</div>
      </div>

      <div class="instructions">
        <strong>How it works:</strong><br>
        ‚Ä¢ Play music in Spotify normally<br>
        ‚Ä¢ Press "Smart Skip" here OR use Spotify's skip button<br>
        ‚Ä¢ AI automatically jumps to the matching beat in the next song<br>
        ‚Ä¢ No more awkward silences or jarring transitions!
      </div>

      <button onclick="logout()" class="btn btn-secondary" style="margin-top: 20px;">
        üö™ Disconnect
      </button>
    </div>
  </div>

  <script>
    // Configuration
    const CLIENT_ID = 'e60ede83721246198bf4fe8a9bee8ca8';
    const REDIRECT_URI = window.location.origin + window.location.pathname;
    const SCOPES = [
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-currently-playing'
    ];

    // Global state
    let accessToken = null;
    let currentTrack = null;
    let currentAnalysis = null;
    let nextTrackAnalysis = null;
    let currentBeat = 0;
    let skipCount = 0;
    let updateInterval = null;
    let isProcessing = false;
    let lastTrackId = null;
    let lastPosition = 0;
    let externalSkipPending = false;
    let manualSkipInProgress = false;

    // Simple Beat Sync AI
    class SimpleBeatSync {
      constructor() {
        this.analysisCache = new Map();
        this.successHistory = [];
      }

      async getBeatAnalysis(trackId) {
        if (this.analysisCache.has(trackId)) {
          return this.analysisCache.get(trackId);
        }

        try {
          const analysis = await spotifyRequest(`/audio-analysis/${trackId}`);
          if (analysis && analysis.beats) {
            const processed = {
              beats: analysis.beats.map((beat, i) => ({
                start: beat.start * 1000, // Convert to ms
                confidence: beat.confidence,
                index: i
              })),
              duration: analysis.track.duration * 1000,
              tempo: analysis.track.tempo
            };
            this.analysisCache.set(trackId, processed);
            return processed;
          }
        } catch (error) {
          console.error('Beat analysis failed:', error);
        }
        return null;
      }

      getCurrentBeat(analysis, positionMs) {
        if (!analysis || !analysis.beats) return 0;

        // Find closest beat to current position
        let closestBeat = 0;
        let minDistance = Infinity;

        for (let i = 0; i < analysis.beats.length; i++) {
          const distance = Math.abs(analysis.beats[i].start - positionMs);
          if (distance < minDistance) {
            minDistance = distance;
            closestBeat = i;
          }
        }
        return closestBeat;
      }

      calculateSyncPoint(currentAnalysis, nextAnalysis, currentBeat) {
        if (!currentAnalysis || !nextAnalysis) {
          return { beat: 0, time: 0, confidence: 0 };
        }

        // Find equivalent position in next track
        const currentProgress = currentBeat / currentAnalysis.beats.length;
        const targetBeat = Math.floor(currentProgress * nextAnalysis.beats.length);
        
        // Ensure valid beat index
        const safeBeat = Math.max(0, Math.min(targetBeat, nextAnalysis.beats.length - 1));
        const seekTime = nextAnalysis.beats[safeBeat].start;
        
        // Calculate confidence based on beat quality and position
        let confidence = 60; // Base confidence
        
        if (currentAnalysis.beats[currentBeat]?.confidence > 0.5) confidence += 20;
        if (nextAnalysis.beats[safeBeat]?.confidence > 0.5) confidence += 20;
        
        // Avoid very beginning or end
        if (currentProgress > 0.1 && currentProgress < 0.9) confidence += 10;
        
        return {
          beat: safeBeat,
          time: seekTime,
          confidence: Math.min(100, confidence)
        };
      }

      recordSuccess(confidence) {
        this.successHistory.push({
          confidence,
          timestamp: Date.now()
        });
        
        // Keep only recent history
        if (this.successHistory.length > 20) {
          this.successHistory.shift();
        }
      }

      getAverageSuccess() {
        if (this.successHistory.length === 0) return 0;
        const sum = this.successHistory.reduce((acc, record) => acc + record.confidence, 0);
        return Math.round(sum / this.successHistory.length);
      }
    }

    const beatSync = new SimpleBeatSync();

    // Authentication functions
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function generateRandomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    async function login() {
      try {
        showStatus('Connecting to Spotify...', 'working');
        
        const state = generateRandomString(16);
        const codeVerifier = generateRandomString(128);
        const codeChallenge = await generateCodeChallenge(codeVerifier);
        
        sessionStorage.setItem('code_verifier', codeVerifier);
        sessionStorage.setItem('state', state);
        
        const authUrl = new URL('https://accounts.spotify.com/authorize');
        authUrl.searchParams.set('response_type', 'code');
        authUrl.searchParams.set('client_id', CLIENT_ID);
        authUrl.searchParams.set('scope', SCOPES.join(' '));
        authUrl.searchParams.set('redirect_uri', REDIRECT_URI);
        authUrl.searchParams.set('state', state);
        authUrl.searchParams.set('code_challenge_method', 'S256');
        authUrl.searchParams.set('code_challenge', codeChallenge);
        
        window.location = authUrl.toString();
      } catch (error) {
        showStatus('Login failed: ' + error.message, 'disconnected');
      }
    }

    async function handleRedirect() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');
      const error = params.get('error');

      if (error) {
        showStatus('Authentication failed: ' + error, 'disconnected');
        return;
      }

      if (!code) return;

      try {
        showStatus('Completing authentication...', 'working');
        
        const storedState = sessionStorage.getItem('state');
        if (state !== storedState) {
          throw new Error('Invalid state parameter');
        }

        const codeVerifier = sessionStorage.getItem('code_verifier');
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code,
            redirect_uri: REDIRECT_URI,
            client_id: CLIENT_ID,
            code_verifier: codeVerifier
          })
        });

        const data = await response.json();
        if (!data.access_token) {
          throw new Error('No access token received');
        }

        accessToken = data.access_token;
        sessionStorage.setItem('access_token', data.access_token);
        
        window.history.replaceState({}, document.title, window.location.pathname);
        sessionStorage.removeItem('code_verifier');
        sessionStorage.removeItem('state');
        
        await initializeApp();
        
      } catch (error) {
        showStatus('Authentication failed: ' + error.message, 'disconnected');
      }
    }

    // Spotify API functions
    async function spotifyRequest(endpoint, options = {}) {
      try {
        const response = await fetch(`https://api.spotify.com/v1${endpoint}`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json',
            ...options.headers
          },
          ...options
        });

        if (response.status === 204) return {};
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        return await response.json();
      } catch (error) {
        console.error('Spotify API error:', error);
        return null;
      }
    }

    async function getCurrentPlayback() {
      return await spotifyRequest('/me/player');
    }

    async function getUserQueue() {
      return await spotifyRequest('/me/player/queue');
    }

    // Enhanced smart skip function that works with manual triggers
    async function smartSkip() {
      if (isProcessing) {
        showStatus('Already processing skip...', 'working');
        return;
      }

      if (!currentTrack) {
        showStatus('No track playing - start music in Spotify', 'disconnected');
        return;
      }

      try {
        isProcessing = true;
        manualSkipInProgress = true;
        document.getElementById('skip-btn').disabled = true;
        showStatus('üéØ Analyzing beats for smart skip...', 'working');

        // Get current playback state
        const playbackState = await getCurrentPlayback();
        if (!playbackState || !playbackState.is_playing) {
          throw new Error('Music not playing');
        }

        const currentPosition = playbackState.progress_ms;
        
        // Get beat analysis for current track
        if (!currentAnalysis) {
          updateAIStatus('Learning current track beats...');
          currentAnalysis = await beatSync.getBeatAnalysis(currentTrack.id);
        }

        // Get next track from queue
        const queue = await getUserQueue();
        if (!queue || !queue.queue || queue.queue.length === 0) {
          throw new Error('No next track in queue');
        }

        const nextTrack = queue.queue[0];
        
        // Get beat analysis for next track
        updateAIStatus('Analyzing next track: ' + nextTrack.name);
        nextTrackAnalysis = await beatSync.getBeatAnalysis(nextTrack.id);

        if (!currentAnalysis || !nextTrackAnalysis) {
          throw new Error('Could not analyze beats - using regular skip');
        }

        // Calculate where we are now
        const currentBeatNum = beatSync.getCurrentBeat(currentAnalysis, currentPosition);
        
        // Calculate sync point
        const syncPoint = beatSync.calculateSyncPoint(currentAnalysis, nextTrackAnalysis, currentBeatNum);
        
        updateAIStatus(`Syncing to beat ${syncPoint.beat} (${Math.round(syncPoint.confidence)}% confidence)`);
        
        // Perform the smart skip
        await performSmartSkip(syncPoint, nextTrack.id);
        
        // Record success
        beatSync.recordSuccess(syncPoint.confidence);
        skipCount++;
        
        showStatus(`‚úÖ Smart skip complete! Synced to beat ${syncPoint.beat}`, 'connected');
        updateSkipCount();
        updateAIStatus(`Success! Average accuracy: ${beatSync.getAverageSuccess()}%`);

      } catch (error) {
        console.error('Smart skip failed:', error);
        showStatus('Smart skip failed: ' + error.message, 'disconnected');
        updateAIStatus('Failed - trying regular skip...');
        
        // Fallback to regular skip
        try {
          await spotifyRequest('/me/player/next', { method: 'POST' });
          skipCount++;
          updateSkipCount();
        } catch (fallbackError) {
          showStatus('All skip methods failed', 'disconnected');
        }
      } finally {
        isProcessing = false;
        document.getElementById('skip-btn').disabled = false;
        setTimeout(() => {
          manualSkipInProgress = false;
        }, 3000);
      }
    }

    // Fixed perform smart skip with proper seek
    async function performSmartSkip(syncPoint, expectedTrackId) {
      console.log(`Smart skip: seeking to beat ${syncPoint.beat} at ${formatTime(syncPoint.time)}`);
      
      // Skip to next track
      await spotifyRequest('/me/player/next', { method: 'POST' });
      
      // Wait and verify track change
      let attempts = 0;
      let trackChanged = false;
      
      while (attempts < 10 && !trackChanged) {
        await new Promise(resolve => setTimeout(resolve, 300));
        const state = await getCurrentPlayback();
        
        if (state && state.item && state.item.id === expectedTrackId) {
          trackChanged = true;
          
          // Seek to calculated position if more than 2 seconds
          if (syncPoint.time > 2000) {
            // Fixed: Use query parameter for position
            await spotifyRequest(`/me/player/seek?position_ms=${Math.floor(syncPoint.time)}`, {
              method: 'PUT'
            });
            
            console.log(`Seeked to ${formatTime(syncPoint.time)}`);
          }
          break;
        }
        attempts++;
      }
      
      if (!trackChanged) {
        console.log('Track change not confirmed, but continuing...');
      }
    }

    // Handle external skips (from Spotify app)
    async function handleExternalSkip(oldTrackId, newTrackId, lastKnownPosition) {
      if (manualSkipInProgress || isProcessing) {
        console.log('Ignoring external skip - manual skip in progress');
        return;
      }

      try {
        // Show indicator
        document.getElementById('external-skip-indicator').style.display = 'block';
        
        console.log(`External skip detected: ${oldTrackId} -> ${newTrackId} at position ${lastKnownPosition}`);
        
        // Get analysis for old track if we don't have it
        let oldAnalysis = currentAnalysis;
        if (!oldAnalysis && oldTrackId) {
          oldAnalysis = await beatSync.getBeatAnalysis(oldTrackId);
        }

        // Get analysis for new track
        const newAnalysis = await beatSync.getBeatAnalysis(newTrackId);

        if (oldAnalysis && newAnalysis) {
          // Calculate where we were
          const lastBeat = beatSync.getCurrentBeat(oldAnalysis, lastKnownPosition);
          
          // Calculate sync point
          const syncPoint = beatSync.calculateSyncPoint(oldAnalysis, newAnalysis, lastBeat);
          
          // Apply the seek if needed
          if (syncPoint.time > 2000) {
            updateAIStatus(`External skip detected - syncing to beat ${syncPoint.beat}`);
            
            // Fixed: Use query parameter for position
            await spotifyRequest(`/me/player/seek?position_ms=${Math.floor(syncPoint.time)}`, {
              method: 'PUT'
            });
            
            beatSync.recordSuccess(syncPoint.confidence);
            skipCount++;
            updateSkipCount();
            
            showStatus(`‚úÖ Auto-synced to beat ${syncPoint.beat}`, 'connected');
          }
        }
        
      } catch (error) {
        console.error('External skip handling failed:', error);
      } finally {
        setTimeout(() => {
          document.getElementById('external-skip-indicator').style.display = 'none';
        }, 2000);
      }
    }

    // Enhanced update function to detect external skips
    async function updatePlaybackInfo() {
      try {
        const playbackState = await getCurrentPlayback();
        
        if (!playbackState || !playbackState.item) {
          document.getElementById('track-name').textContent = 'No Track Playing';
          document.getElementById('track-artist').textContent = 'Start music in Spotify';
          document.getElementById('track-progress').textContent = '0:00 / 0:00';
          document.getElementById('play-btn').innerHTML = '‚ñ∂Ô∏è Play';
          lastTrackId = null;
          return;
        }

        const track = playbackState.item;
        
        // Update track info
        document.getElementById('track-name').textContent = track.name;
        document.getElementById('track-artist').textContent = track.artists.map(a => a.name).join(', ');
        document.getElementById('track-progress').textContent = 
          `${formatTime(playbackState.progress_ms)} / ${formatTime(track.duration_ms)}`;
        document.getElementById('play-btn').innerHTML = playbackState.is_playing ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';

        // Update sync confidence display
        const avgSuccess = beatSync.getAverageSuccess();
        if (avgSuccess > 0) {
          document.getElementById('sync-confidence').textContent = avgSuccess + '%';
        }

        // Update current beat if we have analysis
        if (currentAnalysis && track.id === currentTrack?.id) {
          currentBeat = beatSync.getCurrentBeat(currentAnalysis, playbackState.progress_ms);
          document.getElementById('current-beat').textContent = currentBeat;
        }

        // Detect track changes (external skips)
        if (lastTrackId && lastTrackId !== track.id && !manualSkipInProgress) {
          console.log(`Track changed externally: ${lastTrackId} -> ${track.id}`);
          
          // Handle the external skip
          handleExternalSkip(lastTrackId, track.id, lastPosition);
        }

        // Update tracking variables
        lastTrackId = track.id;
        lastPosition = playbackState.progress_ms;

        // If track changed, update current track and reset analysis
        if (!currentTrack || currentTrack.id !== track.id) {
          currentTrack = track;
          currentAnalysis = null;
          
          // Start analyzing new track in background
          beatSync.getBeatAnalysis(track.id).then(analysis => {
            currentAnalysis = analysis;
            updateAIStatus('Current track analyzed - ready for smart skip!');
          });
        }

      } catch (error) {
        console.error('Update failed:', error);
      }
    }

    async function togglePlayPause() {
      try {
        const playbackState = await getCurrentPlayback();
        if (!playbackState) return;
        
        if (playbackState.is_playing) {
          await spotifyRequest('/me/player/pause', { method: 'PUT' });
        } else {
          await spotifyRequest('/me/player/play', { method: 'PUT' });
        }
      } catch (error) {
        showStatus('Playback control failed', 'disconnected');
      }
    }

    // Update functions
    function updateSkipCount() {
      document.getElementById('skip-count').textContent = skipCount;
    }

    function updateAIStatus(message) {
      document.getElementById('ai-message').textContent = message;
    }

    // Utility functions
    function formatTime(ms) {
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type}`;
    }

    async function initializeApp() {
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('main-interface').style.display = 'block';
      
      showStatus('üéµ Smart Beat Skip ready!', 'connected');
      updateAIStatus('Ready to learn your music patterns');
      
      // Start monitoring playback more frequently for better external skip detection
      updateInterval = setInterval(updatePlaybackInfo, 1000); // Changed from 2000 to 1000
      await updatePlaybackInfo();
    }

    function logout() {
      if (updateInterval) clearInterval(updateInterval);
      accessToken = null;
      sessionStorage.clear();
      
      document.getElementById('login-section').style.display = 'block';
      document.getElementById('main-interface').style.display = 'none';
      showStatus('Disconnected', 'disconnected');
      
      // Reset state
      currentTrack = null;
      currentAnalysis = null;
      nextTrackAnalysis = null;
      currentBeat = 0;
      skipCount = 0;
      lastTrackId = null;
      lastPosition = 0;
    }

    // Initialize on load
    window.onload = async function() {
      showStatus('Loading Smart Beat Skip...', 'working');
      
      const storedToken = sessionStorage.getItem('access_token');
      if (storedToken) {
        accessToken = storedToken;
        await initializeApp();
      } else {
        await handleRedirect();
      }
      
      if (!accessToken) {
        showStatus('Connect to Spotify to begin', 'disconnected');
      }
    };
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>Seamless Beat Skip</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #0a0a0a;
      color: #fff;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 500px;
      width: 100%;
      text-align: center;
    }

    h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      font-weight: 700;
    }

    .subtitle {
      opacity: 0.7;
      margin-bottom: 30px;
    }

    .main-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 20px;
      padding: 30px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .track-info {
      margin-bottom: 30px;
    }

    .track-name {
      font-size: 1.4em;
      font-weight: 600;
      margin-bottom: 5px;
    }

    .track-artist {
      opacity: 0.7;
      margin-bottom: 10px;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
      margin: 15px 0;
    }

    .progress-fill {
      height: 100%;
      background: #1db954;
      width: 0%;
      transition: width 0.3s ease;
    }

    .time-display {
      display: flex;
      justify-content: space-between;
      font-size: 0.85em;
      opacity: 0.6;
    }

    .beat-indicator {
      display: inline-flex;
      gap: 5px;
      margin: 20px 0;
    }

    .beat-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: rgba(29, 185, 84, 0.3);
      transition: all 0.1s ease;
    }

    .beat-dot.active {
      background: #1db954;
      transform: scale(1.5);
    }

    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin: 30px 0;
    }

    .btn {
      padding: 12px 30px;
      border: none;
      border-radius: 25px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 1em;
    }

    .btn-primary {
      background: #1db954;
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: #1ed760;
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.15);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .status {
      margin: 20px 0;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 0.9em;
      display: inline-block;
    }

    .status.ready {
      background: rgba(29, 185, 84, 0.2);
      color: #1ed760;
    }

    .status.processing {
      background: rgba(255, 165, 0, 0.2);
      color: orange;
    }

    .status.error {
      background: rgba(255, 0, 0, 0.2);
      color: #ff4444;
    }

    .queue-preview {
      margin-top: 30px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 15px;
      font-size: 0.9em;
    }

    .queue-label {
      opacity: 0.6;
      margin-bottom: 5px;
    }

    .stats {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
      padding: 20px 0;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 1.8em;
      font-weight: 700;
      color: #1db954;
    }

    .stat-label {
      font-size: 0.8em;
      opacity: 0.6;
      margin-top: 5px;
    }

    .login-section {
      text-align: center;
    }

    .login-section h2 {
      margin-bottom: 20px;
    }

    .login-section p {
      margin-bottom: 30px;
      opacity: 0.8;
      line-height: 1.6;
    }

    /* Simple loading spinner */
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid transparent;
      border-top-color: #1db954;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      vertical-align: middle;
      margin-left: 10px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Seamless Beat Skip</h1>
    <p class="subtitle">Instant beat-matched transitions</p>

    <div id="login-section" class="login-section main-card">
      <h2>ðŸŽµ Smart Music Transitions</h2>
      <p>
        Skip songs with perfect beat matching. No delays, no silence, just smooth transitions
        that maintain the groove. Works with your regular Spotify controls too.
      </p>
      <button onclick="login()" class="btn btn-primary">Connect Spotify</button>
      <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; font-size: 0.85em; text-align: left;">
        <strong>Requirements:</strong>
        <ul style="margin: 10px 0; padding-left: 20px;">
          <li>Spotify Premium account</li>
          <li>Active Spotify app (desktop/mobile/web)</li>
          <li>Music playing in Spotify</li>
        </ul>
      </div>
    </div>

    <div id="main-interface" style="display: none;">
      <div class="main-card">
        <div class="track-info">
          <div class="track-name" id="track-name">No track playing</div>
          <div class="track-artist" id="track-artist">Start playing music</div>
          
          <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
          </div>
          
          <div class="time-display">
            <span id="time-current">0:00</span>
            <span id="time-total">0:00</span>
          </div>
        </div>

        <div class="beat-indicator">
          <div class="beat-dot"></div>
          <div class="beat-dot"></div>
          <div class="beat-dot"></div>
          <div class="beat-dot"></div>
        </div>

        <div class="controls">
          <button onclick="skipWithBeats()" class="btn btn-primary" id="skip-btn">
            Skip âš¡
          </button>
          <button onclick="togglePlayPause()" class="btn btn-secondary" id="play-btn">
            Play
          </button>
        </div>

        <div id="status" class="status ready">Ready</div>

        <div class="stats">
          <div class="stat">
            <div class="stat-value" id="skip-count">0</div>
            <div class="stat-label">Skips</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="beat-accuracy">--</div>
            <div class="stat-label">BPM</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="transition-time">0ms</div>
            <div class="stat-label">Speed</div>
          </div>
        </div>

        <div class="queue-preview">
          <div class="queue-label">Next up:</div>
          <div id="next-track">Loading...</div>
        </div>
      </div>

      <button onclick="logout()" class="btn btn-secondary" style="margin-top: 20px;">
        Disconnect
      </button>
    </div>
  </div>

  <script>
    // Configuration
    const CLIENT_ID = 'e60ede83721246198bf4fe8a9bee8ca8';
    const REDIRECT_URI = window.location.origin + window.location.pathname;
    const SCOPES = [
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-currently-playing',
      'streaming'
    ];

    // Global state
    let accessToken = null;
    let currentTrack = null;
    let nextTrackAnalysis = null;
    let isSkipping = false;
    let skipCount = 0;
    let lastTrackId = null;
    let monitorInterval = null;
    let beatInterval = null;
    let progressInterval = null;
    let currentBPM = 0;
    let prebufferTimeout = null;

    // Beat detection and analysis cache
    const analysisCache = new Map();
    const CACHE_DURATION = 3600000; // 1 hour

    // Professional beat detection based on DJ techniques
    class BeatMatcher {
      constructor() {
        this.phraseLength = 16; // 16 bar phrases (standard in electronic music)
        this.beatsPerBar = 4;
      }

      // Analyze track for beat matching
      async analyze(trackId) {
        // Check cache first
        const cached = analysisCache.get(trackId);
        if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
          return cached.data;
        }

        try {
          // Get audio features for BPM and key
          const features = await spotifyRequest(`/audio-features/${trackId}`);
          if (!features) return this.generateFallback();

          const analysis = {
            bpm: features.tempo,
            key: features.key,
            mode: features.mode,
            energy: features.energy,
            danceability: features.danceability,
            duration: features.duration_ms,
            timeSignature: features.time_signature || 4,
            
            // Calculate beat grid
            beatDuration: 60000 / features.tempo, // ms per beat
            barDuration: (60000 / features.tempo) * this.beatsPerBar,
            phraseDuration: (60000 / features.tempo) * this.beatsPerBar * this.phraseLength,
            
            // DJ-friendly cue points (after intro, usually 16-32 bars in)
            cuePoints: this.calculateCuePoints(features)
          };

          // Cache the analysis
          analysisCache.set(trackId, { data: analysis, timestamp: Date.now() });
          return analysis;

        } catch (error) {
          console.error('Analysis failed:', error);
          return this.generateFallback();
        }
      }

      calculateCuePoints(features) {
        const beatDuration = 60000 / features.tempo;
        const barDuration = beatDuration * this.beatsPerBar;
        const phraseDuration = barDuration * this.phraseLength;

        // Standard DJ cue points
        return [
          phraseDuration,           // After first phrase (intro)
          phraseDuration * 2,       // Second phrase
          phraseDuration * 4,       // Main section
          features.duration_ms * 0.25  // 25% in (usually past intro)
        ].filter(point => point < features.duration_ms * 0.8); // Not too close to end
      }

      // Find optimal transition point
      findTransitionPoint(currentPos, currentAnalysis, nextAnalysis) {
        if (!currentAnalysis || !nextAnalysis) return 0;

        // Calculate current position in phrases
        const currentPhrase = Math.floor(currentPos / currentAnalysis.phraseDuration);
        const positionInPhrase = currentPos % currentAnalysis.phraseDuration;
        const percentInPhrase = positionInPhrase / currentAnalysis.phraseDuration;

        // Find best cue point in next track
        let targetCue = nextAnalysis.cuePoints[0] || 0;

        // If we're early in a phrase, match to the same relative position
        if (percentInPhrase < 0.5) {
          // Find a cue point that aligns with our current phrase position
          const idealTarget = percentInPhrase * nextAnalysis.phraseDuration;
          targetCue = nextAnalysis.cuePoints.reduce((best, cue) => {
            const currentDiff = Math.abs(best - idealTarget);
            const newDiff = Math.abs(cue - idealTarget);
            return newDiff < currentDiff ? cue : best;
          }, nextAnalysis.cuePoints[0]);
        }

        return Math.max(0, Math.floor(targetCue));
      }

      generateFallback() {
        // Intelligent fallback for common BPMs
        return {
          bpm: 128, // Common house/electronic BPM
          beatDuration: 468.75,
          barDuration: 1875,
          phraseDuration: 30000,
          cuePoints: [30000, 60000], // 30s and 60s
          energy: 0.7,
          danceability: 0.8
        };
      }
    }

    const beatMatcher = new BeatMatcher();

    // Spotify Auth Functions
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function generateRandomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      return Array.from({ length }, () => chars[Math.floor(Math.random() * chars.length)]).join('');
    }

    async function login() {
      const state = generateRandomString(16);
      const codeVerifier = generateRandomString(128);
      const codeChallenge = await generateCodeChallenge(codeVerifier);
      
      sessionStorage.setItem('code_verifier', codeVerifier);
      sessionStorage.setItem('state', state);
      
      const authUrl = new URL('https://accounts.spotify.com/authorize');
      authUrl.searchParams.append('response_type', 'code');
      authUrl.searchParams.append('client_id', CLIENT_ID);
      authUrl.searchParams.append('scope', SCOPES.join(' '));
      authUrl.searchParams.append('redirect_uri', REDIRECT_URI);
      authUrl.searchParams.append('state', state);
      authUrl.searchParams.append('code_challenge_method', 'S256');
      authUrl.searchParams.append('code_challenge', codeChallenge);
      
      window.location = authUrl.toString();
    }

    async function handleRedirect() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');

      if (!code) return;

      const storedState = sessionStorage.getItem('state');
      if (state !== storedState) return;

      const codeVerifier = sessionStorage.getItem('code_verifier');
      
      try {
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code,
            redirect_uri: REDIRECT_URI,
            client_id: CLIENT_ID,
            code_verifier: codeVerifier
          })
        });

        const data = await response.json();
        if (data.access_token) {
          accessToken = data.access_token;
          sessionStorage.setItem('access_token', data.access_token);
          window.history.replaceState({}, document.title, window.location.pathname);
          await initializeApp();
        }
      } catch (error) {
        console.error('Auth error:', error);
      }
    }

    // Spotify API wrapper
    async function spotifyRequest(endpoint, options = {}) {
      if (!accessToken) {
        console.error('No access token');
        return null;
      }
      
      try {
        const response = await fetch(`https://api.spotify.com/v1${endpoint}`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json',
            ...options.headers
          },
          ...options
        });

        // Handle different response types
        if (response.status === 204) return true; // No content (success)
        if (response.status === 401) {
          // Token expired
          console.error('Token expired');
          sessionStorage.removeItem('access_token');
          updateStatus('error', 'Session expired - Please reconnect');
          setTimeout(() => window.location.reload(), 2000);
          return null;
        }
        if (response.status === 403) {
          console.error('Forbidden - Premium required or wrong region');
          updateStatus('error', 'Spotify Premium required');
          return null;
        }
        if (!response.ok) {
          console.error(`API Error ${response.status}:`, await response.text());
          return null;
        }
        
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('API error:', error);
        return null;
      }
    }

    // Core skip function - ULTRA FAST
    async function skipWithBeats() {
      if (isSkipping) return;
      
      // Check if we have a current track
      if (!currentTrack) {
        updateStatus('error', 'No track playing');
        return;
      }
      
      isSkipping = true;
      document.getElementById('skip-btn').disabled = true;
      const startTime = performance.now();
      updateStatus('processing', 'Analyzing beats...');
      
      try {
        // Get fresh playback state
        const playback = await spotifyRequest('/me/player');
        if (!playback || !playback.item) {
          throw new Error('No active playback');
        }

        const currentPos = playback.progress_ms || 0;
        const currentAnalysis = await beatMatcher.analyze(currentTrack.id);
        
        // Execute skip immediately
        const skipResult = await spotifyRequest('/me/player/next', { method: 'POST' });
        if (skipResult === null) {
          throw new Error('Skip failed - Check Spotify');
        }
        
        // If we have prebuffered analysis, use it
        if (nextTrackAnalysis) {
          const transitionPoint = beatMatcher.findTransitionPoint(
            currentPos, 
            currentAnalysis, 
            nextTrackAnalysis
          );
          
          // Quick poll for track change (max 1 second)
          let attempts = 0;
          let trackChanged = false;
          
          while (attempts < 20 && !trackChanged) {
            await new Promise(r => setTimeout(r, 50));
            
            const newPlayback = await spotifyRequest('/me/player');
            if (newPlayback && newPlayback.item && newPlayback.item.id !== currentTrack.id) {
              trackChanged = true;
              
              // Apply seek to transition point
              if (transitionPoint > 500) {
                const seekResult = await spotifyRequest(
                  `/me/player/seek?position_ms=${transitionPoint}`, 
                  { method: 'PUT' }
                );
                console.log(`Seeked to ${transitionPoint}ms`);
              }
              break;
            }
            attempts++;
          }
          
          if (!trackChanged) {
            console.log('Track change not detected after skip');
          }
        }
        
        const elapsed = Math.round(performance.now() - startTime);
        document.getElementById('transition-time').textContent = elapsed + 'ms';
        
        skipCount++;
        document.getElementById('skip-count').textContent = skipCount;
        
        updateStatus('ready', 'Seamless transition!');
        
        // Clear prebuffer for next track
        nextTrackAnalysis = null;
        
      } catch (error) {
        console.error('Skip error:', error);
        updateStatus('error', error.message || 'Skip failed');
      } finally {
        isSkipping = false;
        document.getElementById('skip-btn').disabled = false;
      }
    }

    // Monitor playback and prebuffer
    async function monitorPlayback() {
      try {
        const playback = await spotifyRequest('/me/player');
        
        // Debug logging
        console.log('Playback state:', playback);
        
        if (!playback) {
          updateEmptyState();
          updateStatus('error', 'No active Spotify session. Play music in Spotify first.');
          return;
        }
        
        if (!playback.item) {
          updateEmptyState();
          updateStatus('ready', 'Ready - Play something in Spotify');
          return;
        }

        // Check if it's a track (not podcast/episode)
        if (playback.currently_playing_type !== 'track') {
          updateEmptyState();
          updateStatus('error', 'Only music tracks supported');
          return;
        }

        const track = playback.item;
        const progress = playback.progress_ms || 0;
        const duration = track.duration_ms || 0;
        
        // Update UI
        updateTrackDisplay(track, progress, duration);
        updateStatus('ready', 'Ready');
        
        // Handle track changes
        if (lastTrackId && lastTrackId !== track.id) {
          // Track changed naturally (not from our skip)
          if (!isSkipping) {
            handleNaturalTrackChange();
          }
        }
        
        lastTrackId = track.id;
        currentTrack = track;
        
        // Update play button
        document.getElementById('play-btn').textContent = playback.is_playing ? 'Pause' : 'Play';
        
        // Prebuffer next track when we're 75% through current track
        const percentComplete = progress / duration;
        if (percentComplete > 0.75 && !prebufferTimeout) {
          prebufferTimeout = setTimeout(prebufferNextTrack, 0);
        }
        
        // Reset prebuffer timeout on new track
        if (percentComplete < 0.1) {
          clearTimeout(prebufferTimeout);
          prebufferTimeout = null;
        }

        // Show BPM if we have it
        if (currentTrack) {
          beatMatcher.analyze(currentTrack.id).then(analysis => {
            if (analysis?.bpm) {
              currentBPM = Math.round(analysis.bpm);
              document.getElementById('beat-accuracy').textContent = currentBPM;
            }
          });
        }
        
      } catch (error) {
        console.error('Monitor error:', error);
        updateStatus('error', 'Connection error - Refresh page');
      }
    }

    // Prebuffer next track analysis
    async function prebufferNextTrack() {
      try {
        const queue = await spotifyRequest('/me/player/queue');
        if (queue?.queue?.length > 0) {
          const nextTrack = queue.queue[0];
          
          // Update next track display
          document.getElementById('next-track').textContent = 
            `${nextTrack.name} - ${nextTrack.artists[0].name}`;
          
          // Analyze in background
          nextTrackAnalysis = await beatMatcher.analyze(nextTrack.id);
          console.log('Prebuffered next track:', nextTrack.name);
        }
      } catch (error) {
        console.error('Prebuffer error:', error);
      }
    }

    // Handle natural track progression
    function handleNaturalTrackChange() {
      // Clear prebuffer
      nextTrackAnalysis = null;
      clearTimeout(prebufferTimeout);
      prebufferTimeout = null;
      
      // Update stats
      updateStatus('ready', 'Track changed');
    }

    // UI Updates
    function updateTrackDisplay(track, progress, duration) {
      document.getElementById('track-name').textContent = track.name;
      document.getElementById('track-artist').textContent = 
        track.artists.map(a => a.name).join(', ');
      
      // Update progress
      const percent = (progress / duration) * 100;
      document.getElementById('progress-fill').style.width = percent + '%';
      
      document.getElementById('time-current').textContent = formatTime(progress);
      document.getElementById('time-total').textContent = formatTime(duration);
    }

    function updateEmptyState() {
      document.getElementById('track-name').textContent = 'No track playing';
      document.getElementById('track-artist').textContent = 'Start playing music';
      document.getElementById('progress-fill').style.width = '0%';
      document.getElementById('time-current').textContent = '0:00';
      document.getElementById('time-total').textContent = '0:00';
      document.getElementById('beat-accuracy').textContent = '--';
      currentTrack = null;
    }

    function updateStatus(type, message) {
      const status = document.getElementById('status');
      status.className = `status ${type}`;
      status.innerHTML = type === 'processing' ? message + '<span class="spinner"></span>' : message;
    }

    function formatTime(ms) {
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Beat visualization
    function animateBeats() {
      if (!currentBPM) return;
      
      const beatDuration = 60000 / currentBPM;
      const dots = document.querySelectorAll('.beat-dot');
      let currentBeat = 0;
      
      setInterval(() => {
        dots.forEach(d => d.classList.remove('active'));
        dots[currentBeat].classList.add('active');
        currentBeat = (currentBeat + 1) % dots.length;
      }, beatDuration);
    }

    // Playback controls
    async function togglePlayPause() {
      try {
        const playback = await spotifyRequest('/me/player');
        if (!playback) {
          updateStatus('error', 'No active Spotify device');
          return;
        }
        
        if (playback.is_playing) {
          await spotifyRequest('/me/player/pause', { method: 'PUT' });
        } else {
          await spotifyRequest('/me/player/play', { method: 'PUT' });
        }
      } catch (error) {
        console.error('Playback control error:', error);
        updateStatus('error', 'Playback control failed');
      }
    }

    // Initialize app
    async function initializeApp() {
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('main-interface').style.display = 'block';
      
      updateStatus('ready', 'Connecting to Spotify...');
      
      // Test the connection first
      const testConnection = await spotifyRequest('/me');
      if (!testConnection) {
        updateStatus('error', 'Failed to connect. Please reconnect.');
        setTimeout(() => {
          logout();
        }, 2000);
        return;
      }
      
      console.log('Connected as:', testConnection.display_name);
      
      // Check for active playback
      const playback = await spotifyRequest('/me/player');
      if (!playback) {
        updateStatus('ready', 'Ready - Start playing music in Spotify');
      } else {
        updateStatus('ready', 'Connected and ready!');
      }
      
      // Start monitoring with fast interval
      monitorInterval = setInterval(monitorPlayback, 500);
      await monitorPlayback();
      
      // Start beat animation
      setTimeout(animateBeats, 1000);
    }

    function logout() {
      clearInterval(monitorInterval);
      clearInterval(beatInterval);
      clearInterval(progressInterval);
      clearTimeout(prebufferTimeout);
      
      accessToken = null;
      sessionStorage.clear();
      window.location.reload();
    }

    // Initialize on load
    window.onload = async function() {
      const storedToken = sessionStorage.getItem('access_token');
      if (storedToken) {
        accessToken = storedToken;
        await initializeApp();
      } else {
        await handleRedirect();
      }
    };

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (!accessToken) return;
      
      switch(e.code) {
        case 'Space':
          e.preventDefault();
          togglePlayPause();
          break;
        case 'ArrowRight':
          e.preventDefault();
          skipWithBeats();
          break;
      }
    });
  </script>
</body>
</html>

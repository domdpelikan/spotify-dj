<!DOCTYPE html>
<html>
<head>
  <title>AI DJ - Professional Beat Mixing</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #000;
      color: white;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      position: relative;
      overflow: hidden;
    }

    /* DJ Booth Background */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 50%, rgba(138, 43, 226, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 50%, rgba(29, 185, 84, 0.3) 0%, transparent 50%),
        linear-gradient(180deg, #0a0a0a 0%, #1a1a1a 100%);
      animation: booth-lights 10s ease-in-out infinite;
    }

    @keyframes booth-lights {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    .container {
      max-width: 1200px;
      width: 100%;
      text-align: center;
      position: relative;
      z-index: 1;
    }

    .header h1 {
      font-size: 4.5em;
      font-weight: 900;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 4px;
      background: linear-gradient(45deg, #ff0080, #7928ca, #ff0080);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: neon-glow 3s ease-in-out infinite;
    }

    @keyframes neon-glow {
      0%, 100% { 
        background-position: 0% 50%;
        filter: drop-shadow(0 0 20px rgba(255, 0, 128, 0.5));
      }
      50% { 
        background-position: 100% 50%;
        filter: drop-shadow(0 0 30px rgba(121, 40, 202, 0.8));
      }
    }

    .subtitle {
      font-size: 1.4em;
      opacity: 0.9;
      margin-bottom: 30px;
      font-weight: 300;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    /* DJ Mixer Interface */
    .dj-mixer {
      background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
      border-radius: 20px;
      padding: 30px;
      margin: 30px 0;
      box-shadow: 
        0 10px 40px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      position: relative;
    }

    .deck-container {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }

    .deck {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 15px;
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .deck-label {
      font-size: 0.9em;
      text-transform: uppercase;
      opacity: 0.7;
      margin-bottom: 10px;
      letter-spacing: 1px;
    }

    .track-display {
      background: #000;
      border: 2px solid #1db954;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .track-display.deck-b {
      border-color: #ff0080;
    }

    .track-name {
      font-weight: 600;
      font-size: 1.1em;
      margin-bottom: 5px;
      color: #fff;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .track-artist {
      font-size: 0.9em;
      opacity: 0.8;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .waveform-display {
      height: 100px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      position: relative;
      overflow: hidden;
      margin-bottom: 15px;
    }

    .waveform-scrolling {
      position: absolute;
      height: 100%;
      display: flex;
      align-items: center;
      transition: transform 0.1s linear;
    }

    .waveform-bar {
      width: 3px;
      margin: 0 1px;
      background: linear-gradient(to top, #1db954, #1ed760);
      opacity: 0.8;
    }

    .deck-b .waveform-bar {
      background: linear-gradient(to top, #ff0080, #ff4da6);
    }

    .playhead {
      position: absolute;
      left: 50%;
      top: 0;
      width: 2px;
      height: 100%;
      background: white;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
      z-index: 10;
    }

    /* Crossfader */
    .crossfader-section {
      background: rgba(0, 0, 0, 0.6);
      border-radius: 15px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .crossfader-container {
      width: 100%;
      max-width: 300px;
      margin: 20px 0;
    }

    .crossfader {
      -webkit-appearance: none;
      width: 100%;
      height: 60px;
      background: linear-gradient(to right, #1db954 0%, #333 50%, #ff0080 100%);
      border-radius: 30px;
      outline: none;
      cursor: pointer;
      position: relative;
    }

    .crossfader::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 40px;
      height: 80px;
      background: linear-gradient(145deg, #f0f0f0, #d0d0d0);
      border: 2px solid #888;
      border-radius: 10px;
      cursor: grab;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    }

    .crossfader:active::-webkit-slider-thumb {
      cursor: grabbing;
      background: linear-gradient(145deg, #d0d0d0, #b0b0b0);
    }

    .crossfader-label {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      font-size: 0.9em;
      opacity: 0.7;
    }

    /* EQ Knobs */
    .eq-section {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      margin-top: 20px;
    }

    .eq-knob {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .knob {
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, #444, #222);
      border-radius: 50%;
      position: relative;
      cursor: pointer;
      box-shadow: 
        0 5px 15px rgba(0, 0, 0, 0.5),
        inset 0 -2px 5px rgba(0, 0, 0, 0.5);
    }

    .knob::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 50%;
      width: 3px;
      height: 40%;
      background: #1db954;
      transform: translateX(-50%);
      border-radius: 2px;
    }

    .knob-label {
      margin-top: 10px;
      font-size: 0.8em;
      text-transform: uppercase;
      opacity: 0.7;
    }

    /* Effects Section */
    .effects-panel {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 15px;
      padding: 20px;
      margin: 20px 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }

    .effect-btn {
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      font-size: 0.9em;
      font-weight: 600;
      position: relative;
      overflow: hidden;
    }

    .effect-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
    }

    .effect-btn.active {
      background: linear-gradient(145deg, #1db954, #1ed760);
      border-color: #1db954;
      box-shadow: 0 0 20px rgba(29, 185, 84, 0.5);
    }

    /* BPM Display */
    .bpm-display {
      font-size: 3em;
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      margin: 10px 0;
      text-shadow: 0 0 20px currentColor;
    }

    .deck-a .bpm-display {
      color: #1db954;
    }

    .deck-b .bpm-display {
      color: #ff0080;
    }

    /* Sync indicator */
    .sync-indicator {
      display: inline-block;
      padding: 5px 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      font-size: 0.8em;
      margin-top: 10px;
    }

    .sync-indicator.synced {
      background: rgba(29, 185, 84, 0.3);
      color: #1ed760;
    }

    /* Controls */
    .transport-controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 30px 0;
    }

    .btn {
      padding: 15px 35px;
      font-size: 1.1em;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      overflow: hidden;
    }

    .btn-primary {
      background: linear-gradient(135deg, #ff0080, #7928ca);
      color: white;
      box-shadow: 0 4px 20px rgba(255, 0, 128, 0.4);
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 8px 30px rgba(255, 0, 128, 0.6);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    /* AI Status */
    .ai-dj-status {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 0, 128, 0.5);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(20px);
      max-width: 250px;
    }

    .ai-status-title {
      font-size: 1.1em;
      font-weight: 600;
      margin-bottom: 10px;
      color: #ff0080;
    }

    .ai-metric {
      display: flex;
      justify-content: space-between;
      margin: 8px 0;
      font-size: 0.9em;
    }

    .ai-metric-value {
      color: #1ed760;
      font-weight: 600;
    }

    /* Visualizer */
    .spectrum-visualizer {
      height: 150px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 15px;
      margin: 20px 0;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: flex-end;
      justify-content: space-around;
      padding: 10px;
    }

    .spectrum-bar {
      width: 4px;
      background: linear-gradient(to top, #ff0080, #7928ca, #1ed760);
      border-radius: 2px;
      transition: height 0.1s ease;
    }

    /* Loading State */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .loading-overlay.active {
      display: flex;
    }

    .turntable-loader {
      width: 100px;
      height: 100px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top: 3px solid #ff0080;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Login Section */
    .login-section {
      padding: 60px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 30px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: 600px;
      margin: 0 auto;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header h1 { font-size: 3em; }
      .deck-container { grid-template-columns: 1fr; }
      .crossfader-section { order: -1; }
      .ai-dj-status { position: relative; top: 0; right: 0; margin: 20px auto; }
    }

    /* Status Bar */
    .status {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      border-radius: 50px;
      font-weight: 600;
      font-size: 1em;
      backdrop-filter: blur(20px);
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    .status.connected {
      background: rgba(29, 185, 84, 0.2);
      border: 1px solid #1db954;
    }

    .status.mixing {
      background: rgba(255, 0, 128, 0.2);
      border: 1px solid #ff0080;
      animation: pulse-mix 1s ease-in-out infinite;
    }

    @keyframes pulse-mix {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Debug panel for troubleshooting */
    .debug-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid #333;
      border-radius: 10px;
      padding: 15px;
      font-family: monospace;
      font-size: 12px;
      max-width: 300px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
    }

    .debug-panel.active {
      display: block;
    }

    .load-buttons {
      display: flex;
      gap: 10px;
      margin: 20px 0;
    }

    .btn-small {
      padding: 10px 20px;
      font-size: 0.9em;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      transition: all 0.3s ease;
    }

    .btn-small:hover {
      background: rgba(255, 255, 255, 0.2);
    }
  </style>
</head>
<body>
  <div class="ai-dj-status">
    <div class="ai-status-title">üéß AI DJ STATUS</div>
    <div class="ai-metric">
      <span>Mix Quality</span>
      <span class="ai-metric-value" id="mix-quality">PRO</span>
    </div>
    <div class="ai-metric">
      <span>Beat Match</span>
      <span class="ai-metric-value" id="beat-match">100%</span>
    </div>
    <div class="ai-metric">
      <span>Harmonic Mix</span>
      <span class="ai-metric-value" id="harmonic-mix">ON</span>
    </div>
    <div class="ai-metric">
      <span>Auto-Mix</span>
      <span class="ai-metric-value" id="auto-mix">READY</span>
    </div>
  </div>

  <div class="container">
    <div class="header">
      <h1>AI DJ</h1>
      <p class="subtitle">Professional Beat Mixing System</p>
    </div>

    <div id="status" class="status connected">System Ready</div>

    <div id="login-section" class="login-section">
      <h2 style="margin-bottom: 20px; font-size: 2.5em; font-weight: 300;">üéõÔ∏è Professional AI DJ</h2>
      <p style="margin-bottom: 30px; line-height: 1.8; opacity: 0.9;">
        Experience true DJ-style mixing with AI. Seamless beatmatched transitions, 
        harmonic mixing, crossfading, EQ blending, and professional effects. 
        The AI learns your style and creates perfect mixes every time.
      </p>
      <button onclick="login()" class="btn btn-primary">Launch DJ Mode</button>
      <p style="margin-top: 20px; font-size: 0.9em; opacity: 0.6;">
        Spotify Premium required ‚Ä¢ Professional mixing algorithms
      </p>
    </div>

    <div id="main-interface" class="main-interface" style="display: none;">
      <div class="load-buttons">
        <button onclick="loadCurrentTrack()" class="btn-small">Load Current Track</button>
        <button onclick="loadRecentTracks()" class="btn-small">Load Recent Tracks</button>
        <button onclick="loadTopTracks()" class="btn-small">Load Top Tracks</button>
        <button onclick="toggleDebug()" class="btn-small">Debug</button>
      </div>

      <div class="dj-mixer">
        <div class="deck-container">
          <!-- Deck A -->
          <div class="deck deck-a">
            <div class="deck-label">Deck A</div>
            <div class="track-display">
              <div class="track-name" id="track-a-name">Empty</div>
              <div class="track-artist" id="track-a-artist">Load track</div>
            </div>
            <div class="waveform-display">
              <div class="waveform-scrolling" id="waveform-a"></div>
              <div class="playhead"></div>
            </div>
            <div class="bpm-display" id="bpm-a">0.0</div>
            <div class="sync-indicator" id="sync-a">NOT SYNCED</div>
            <div class="eq-section">
              <div class="eq-knob">
                <div class="knob" id="eq-high-a"></div>
                <div class="knob-label">HIGH</div>
              </div>
              <div class="eq-knob">
                <div class="knob" id="eq-mid-a"></div>
                <div class="knob-label">MID</div>
              </div>
              <div class="eq-knob">
                <div class="knob" id="eq-low-a"></div>
                <div class="knob-label">LOW</div>
              </div>
            </div>
          </div>

          <!-- Crossfader -->
          <div class="crossfader-section">
            <div class="deck-label">CROSSFADER</div>
            <div class="crossfader-container">
              <input type="range" class="crossfader" id="crossfader" 
                     min="0" max="100" value="0" step="1">
              <div class="crossfader-label">
                <span>A</span>
                <span>MIX</span>
                <span>B</span>
              </div>
            </div>
            <button class="effect-btn" id="auto-mix-btn" onclick="toggleAutoMix()">
              AUTO MIX
            </button>
          </div>

          <!-- Deck B -->
          <div class="deck deck-b">
            <div class="deck-label">Deck B</div>
            <div class="track-display deck-b">
              <div class="track-name" id="track-b-name">Empty</div>
              <div class="track-artist" id="track-b-artist">Load track</div>
            </div>
            <div class="waveform-display">
              <div class="waveform-scrolling" id="waveform-b"></div>
              <div class="playhead"></div>
            </div>
            <div class="bpm-display" id="bpm-b">0.0</div>
            <div class="sync-indicator" id="sync-b">NOT SYNCED</div>
            <div class="eq-section">
              <div class="eq-knob">
                <div class="knob" id="eq-high-b"></div>
                <div class="knob-label">HIGH</div>
              </div>
              <div class="eq-knob">
                <div class="knob" id="eq-mid-b"></div>
                <div class="knob-label">MID</div>
              </div>
              <div class="eq-knob">
                <div class="knob" id="eq-low-b"></div>
                <div class="knob-label">LOW</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Effects Panel -->
        <div class="effects-panel">
          <button class="effect-btn" onclick="applyEffect('filter')">FILTER</button>
          <button class="effect-btn" onclick="applyEffect('reverb')">REVERB</button>
          <button class="effect-btn" onclick="applyEffect('delay')">DELAY</button>
          <button class="effect-btn" onclick="applyEffect('loop')">LOOP</button>
          <button class="effect-btn" onclick="applyEffect('scratch')">SCRATCH</button>
          <button class="effect-btn" onclick="applyEffect('fade')">FADE</button>
        </div>

        <!-- Spectrum Visualizer -->
        <div class="spectrum-visualizer" id="spectrum"></div>
      </div>

      <div class="transport-controls">
        <button onclick="smartMix()" class="btn btn-primary" id="mix-btn">
          üéõÔ∏è AI MIX
        </button>
        <button onclick="togglePlayPause()" class="btn btn-secondary" id="play-btn">
          ‚ñ∂Ô∏è PLAY
        </button>
        <button onclick="loadNextTrack()" class="btn btn-secondary">
          ‚è≠Ô∏è QUEUE
        </button>
      </div>

      <button onclick="logout()" class="btn btn-secondary" style="margin-top: 30px;">
        EXIT DJ MODE
      </button>
    </div>
  </div>

  <div class="loading-overlay" id="loading-overlay">
    <div class="turntable-loader"></div>
  </div>

  <div class="debug-panel" id="debug-panel">
    <div id="debug-content">Debug info will appear here...</div>
  </div>

  <script>
    // Configuration
    const CLIENT_ID = 'e60ede83721246198bf4fe8a9bee8ca8';
    const REDIRECT_URI = window.location.origin + window.location.pathname;
    const SCOPES = [
      'user-read-playback-state',
      'user-modify-playback-state',
      'user-read-currently-playing',
      'user-read-playback-position',
      'streaming',
      'user-read-recently-played',
      'user-library-read',
      'user-top-read'
    ];

    // Global state
    let accessToken = null;
    let currentDeck = 'A';
    let deckA = { track: null, analysis: null, volume: 1, eq: { high: 0, mid: 0, low: 0 } };
    let deckB = { track: null, analysis: null, volume: 0, eq: { high: 0, mid: 0, low: 0 } };
    let crossfaderPosition = 0;
    let autoMixActive = false;
    let mixInProgress = false;
    let djAI = null;
    let debugMode = false;

    // Debug logging
    function debugLog(message) {
      console.log(message);
      if (debugMode) {
        const debugContent = document.getElementById('debug-content');
        if (debugContent) {
          debugContent.innerHTML += `${new Date().toLocaleTimeString()}: ${message}<br>`;
          debugContent.scrollTop = debugContent.scrollHeight;
        }
      }
    }

    function toggleDebug() {
      debugMode = !debugMode;
      const debugPanel = document.getElementById('debug-panel');
      debugPanel.classList.toggle('active');
    }

    // Professional DJ AI System
    class ProfessionalDJAI {
      constructor() {
        this.audioContext = null;
        this.analyser = null;
        
        // DJ knowledge base
        this.mixingTechniques = {
          beatmatch: { confidence: 0.9, learned: 100 },
          harmonic: { confidence: 0.85, learned: 80 },
          phrase: { confidence: 0.8, learned: 70 },
          energy: { confidence: 0.9, learned: 90 }
        };
        
        // Harmonic mixing wheel (Camelot)
        this.camelotWheel = {
          '1A': ['12A', '2A', '1B'], '1B': ['12B', '2B', '1A'],
          '2A': ['1A', '3A', '2B'], '2B': ['1B', '3B', '2A'],
          '3A': ['2A', '4A', '3B'], '3B': ['2B', '4B', '3A'],
          '4A': ['3A', '5A', '4B'], '4B': ['3B', '5B', '4A'],
          '5A': ['4A', '6A', '5B'], '5B': ['4B', '6B', '5A'],
          '6A': ['5A', '7A', '6B'], '6B': ['5B', '7B', '6A'],
          '7A': ['6A', '8A', '7B'], '7B': ['6B', '8B', '7A'],
          '8A': ['7A', '9A', '8B'], '8B': ['7B', '9B', '8A'],
          '9A': ['8A', '10A', '9B'], '9B': ['8B', '10B', '9A'],
          '10A': ['9A', '11A', '10B'], '10B': ['9B', '11B', '10A'],
          '11A': ['10A', '12A', '11B'], '11B': ['10B', '12B', '11A'],
          '12A': ['11A', '1A', '12B'], '12B': ['11B', '1B', '12A']
        };
        
        // Mix history for learning
        this.mixHistory = [];
        this.beatGrids = new Map();
        
        this.initAudio();
      }

      async initAudio() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.analyser = this.audioContext.createAnalyser();
          this.analyser.fftSize = 2048;
          this.analyser.smoothingTimeConstant = 0.8;
        } catch (e) {
          debugLog('Audio context will be initialized on user interaction');
        }
      }

      // Convert key and mode to Camelot notation
      toCamelot(key, mode) {
        const keyMap = {
          0: mode ? '8B' : '5A',   // C
          1: mode ? '3B' : '12A',  // C#/Db
          2: mode ? '10B' : '7A',  // D
          3: mode ? '5B' : '2A',   // D#/Eb
          4: mode ? '12B' : '9A',  // E
          5: mode ? '7B' : '4A',   // F
          6: mode ? '2B' : '11A',  // F#/Gb
          7: mode ? '9B' : '6A',   // G
          8: mode ? '4B' : '1A',   // G#/Ab
          9: mode ? '11B' : '8A',  // A
          10: mode ? '6B' : '3A',  // A#/Bb
          11: mode ? '1B' : '10A'  // B
        };
        return keyMap[key] || '5A';
      }

      // Analyze track for DJ mixing
      async analyzeForMixing(trackId) {
        try {
          debugLog(`Analyzing track: ${trackId}`);
          const [features, analysis, track] = await Promise.all([
            spotifyRequest(`/audio-features/${trackId}`),
            this.getDetailedAnalysis(trackId),
            spotifyRequest(`/tracks/${trackId}`)
          ]);

          if (!features) {
            debugLog('No audio features found, using fallback');
            return this.generateFallbackAnalysis(trackId);
          }

          const camelotKey = this.toCamelot(features.key, features.mode);
          
          const result = {
            id: trackId,
            name: track?.name || 'Unknown',
            artist: track?.artists?.[0]?.name || 'Unknown',
            
            // Timing
            tempo: features.tempo,
            time_signature: features.time_signature,
            duration_ms: features.duration_ms,
            
            // Harmonic
            key: features.key,
            mode: features.mode,
            camelotKey: camelotKey,
            compatibleKeys: this.camelotWheel[camelotKey] || [],
            
            // Energy & Mood
            energy: features.energy,
            danceability: features.danceability,
            valence: features.valence,
            
            // Mix points
            introOutroBeats: this.detectIntroOutro(analysis),
            phrases: this.detectPhrases(analysis),
            breakdowns: this.detectBreakdowns(analysis),
            
            // Beatgrid
            beatGrid: this.generateBeatGrid(features.tempo, features.duration_ms)
          };
          
          debugLog(`Analysis complete: ${result.name} - ${result.tempo} BPM`);
          return result;
        } catch (error) {
          debugLog(`Mix analysis failed: ${error.message}`);
          return this.generateFallbackAnalysis(trackId);
        }
      }

      // Detailed analysis for professional mixing
      async getDetailedAnalysis(trackId) {
        try {
          const analysis = await spotifyRequest(`/audio-analysis/${trackId}`);
          return analysis || {};
        } catch (error) {
          debugLog(`Detailed analysis failed: ${error.message}`);
          return {};
        }
      }

      // Detect intro and outro sections
      detectIntroOutro(analysis) {
        if (!analysis || !analysis.sections) {
          return { intro: 0, outro: 180000 }; // Default 3 min
        }

        const sections = analysis.sections;
        const intro = sections[0]?.start * 1000 || 0;
        const outro = sections[sections.length - 1]?.start * 1000 || 180000;

        return { intro, outro };
      }

      // Detect 16/32 bar phrases for mixing
      detectPhrases(analysis) {
        const phrases = [];
        const barLength = 60000 / (analysis?.track?.tempo || 120) * 4; // 4 beats per bar
        const phraseLength = barLength * 16; // 16 bar phrases

        for (let time = 0; time < (analysis?.track?.duration || 180) * 1000; time += phraseLength) {
          phrases.push({
            start: time,
            end: time + phraseLength,
            type: this.classifyPhrase(time, analysis)
          });
        }

        return phrases;
      }

      classifyPhrase(time, analysis) {
        // Classify phrase type based on position and energy
        const relativePosition = time / ((analysis?.track?.duration || 180) * 1000);
        
        if (relativePosition < 0.1) return 'intro';
        if (relativePosition > 0.9) return 'outro';
        if (relativePosition > 0.4 && relativePosition < 0.6) return 'breakdown';
        
        return 'main';
      }

      // Detect breakdowns and builds
      detectBreakdowns(analysis) {
        const breakdowns = [];
        
        if (analysis?.sections) {
          analysis.sections.forEach((section, idx) => {
            if (section.loudness < -15 || section.tempo_confidence < 0.5) {
              breakdowns.push({
                start: section.start * 1000,
                duration: section.duration * 1000,
                type: 'breakdown'
              });
            }
          });
        }
        
        return breakdowns;
      }

      // Generate precise beat grid
      generateBeatGrid(tempo, duration) {
        const beatGrid = [];
        const msPerBeat = 60000 / tempo;
        const totalBeats = Math.floor(duration / msPerBeat);

        for (let i = 0; i < totalBeats; i++) {
          beatGrid.push({
            time: i * msPerBeat,
            beat: i % 4 + 1,
            bar: Math.floor(i / 4) + 1,
            phrase: Math.floor(i / 64) + 1 // 16 bar phrases
          });
        }

        return beatGrid;
      }

      // Generate fallback when API fails
      generateFallbackAnalysis(trackId) {
        debugLog(`Generating fallback analysis for: ${trackId}`);
        return {
          id: trackId,
          name: 'Unknown Track',
          artist: 'Unknown Artist',
          tempo: 128,
          camelotKey: '5A',
          compatibleKeys: ['4A', '6A', '5B'],
          energy: 0.7,
          danceability: 0.8,
          introOutroBeats: { intro: 0, outro: 180000 },
          phrases: this.generateDefaultPhrases(),
          beatGrid: this.generateBeatGrid(128, 180000)
        };
      }

      generateDefaultPhrases() {
        const phrases = [];
        for (let i = 0; i < 12; i++) {
          phrases.push({
            start: i * 16000,
            end: (i + 1) * 16000,
            type: i === 0 ? 'intro' : i === 11 ? 'outro' : 'main'
          });
        }
        return phrases;
      }

      // Real-time spectrum analysis
      getSpectrum() {
        if (!this.analyser) return new Array(32).fill(0);
        
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        this.analyser.getByteFrequencyData(dataArray);
        
        // Compress to 32 bands for visualization
        const bands = 32;
        const samplesPerBand = Math.floor(bufferLength / bands);
        const spectrum = [];
        
        for (let i = 0; i < bands; i++) {
          let sum = 0;
          for (let j = 0; j < samplesPerBand; j++) {
            sum += dataArray[i * samplesPerBand + j];
          }
          spectrum.push(sum / samplesPerBand / 255);
        }
        
        return spectrum;
      }
    }

    // Initialize DJ AI
    djAI = new ProfessionalDJAI();

    // Spotify Authentication
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function generateRandomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    async function login() {
      try {
        showStatus('Initializing DJ system...', 'connected');
        debugLog('Starting login process');
        
        const state = generateRandomString(16);
        const codeVerifier = generateRandomString(128);
        const codeChallenge = await generateCodeChallenge(codeVerifier);
        
        sessionStorage.setItem('code_verifier', codeVerifier);
        sessionStorage.setItem('state', state);
        
        const authUrl = new URL('https://accounts.spotify.com/authorize');
        authUrl.searchParams.set('response_type', 'code');
        authUrl.searchParams.set('client_id', CLIENT_ID);
        authUrl.searchParams.set('scope', SCOPES.join(' '));
        authUrl.searchParams.set('redirect_uri', REDIRECT_URI);
        authUrl.searchParams.set('state', state);
        authUrl.searchParams.set('code_challenge_method', 'S256');
        authUrl.searchParams.set('code_challenge', codeChallenge);
        
        window.location = authUrl.toString();
      } catch (error) {
        debugLog(`Login failed: ${error.message}`);
        showStatus('Login failed: ' + error.message, 'connected');
      }
    }

    async function handleRedirect() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');
      const error = params.get('error');

      if (error) {
        debugLog(`Authentication error: ${error}`);
        showStatus('Authentication failed', 'connected');
        return;
      }

      if (!code) return;

      try {
        showStatus('Loading DJ system...', 'connected');
        debugLog('Handling OAuth redirect');
        
        const storedState = sessionStorage.getItem('state');
        if (state !== storedState) {
          throw new Error('Invalid state');
        }

        const codeVerifier = sessionStorage.getItem('code_verifier');
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            code,
            redirect_uri: REDIRECT_URI,
            client_id: CLIENT_ID,
            code_verifier: codeVerifier
          })
        });

        const data = await response.json();
        if (!data.access_token) {
          throw new Error('No access token received');
        }

        accessToken = data.access_token;
        sessionStorage.setItem('access_token', data.access_token);
        debugLog('Access token obtained successfully');
        
        window.history.replaceState({}, document.title, window.location.pathname);
        
        await initializeDJ();
        
      } catch (error) {
        debugLog(`Setup failed: ${error.message}`);
        showStatus('Setup failed', 'connected');
      }
    }

    // Enhanced Spotify API wrapper with better error handling
    async function spotifyRequest(endpoint, options = {}) {
      try {
        debugLog(`API Request: ${endpoint}`);
        const response = await fetch(`https://api.spotify.com/v1${endpoint}`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json',
            ...options.headers
          },
          ...options
        });

        if (response.status === 204) return {};
        if (response.status === 401) {
          debugLog('Token expired, need to re-authenticate');
          accessToken = null;
          sessionStorage.removeItem('access_token');
          showStatus('Session expired - please login again', 'connected');
          return null;
        }
        if (!response.ok) {
          debugLog(`API Error: HTTP ${response.status}`);
          throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        debugLog(`API Response received for ${endpoint}`);
        return data;
      } catch (error) {
        debugLog(`Spotify API error: ${error.message}`);
        return null;
      }
    }

    // Enhanced DJ Interface Functions
    async function initializeDJ() {
      debugLog('Initializing DJ interface');
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('main-interface').style.display = 'block';
      
      showStatus('DJ System Ready', 'connected');
      
      // Try to load current track automatically
      await loadCurrentTrack();
      
      // Initialize visualizers
      initializeVisualizers();
      
      // Start monitoring
      setInterval(updateDJInterface, 1000);
    }

    // New function to load current playing track
    async function loadCurrentTrack() {
      debugLog('Attempting to load current track');
      showLoading();
      
      try {
        const playback = await spotifyRequest('/me/player');
        debugLog(`Playback state: ${JSON.stringify(playback?.item?.name || 'No current track')}`);
        
        if (playback && playback.item && playback.item.id) {
          debugLog(`Loading current track: ${playback.item.name}`);
          await loadToDeck('A', playback.item);
          showStatus('Current track loaded', 'connected');
        } else {
          debugLog('No current track playing, trying recent tracks');
          await loadRecentTracks();
        }
      } catch (error) {
        debugLog(`Failed to load current track: ${error.message}`);
        showStatus('No current track - load manually', 'connected');
      } finally {
        hideLoading();
      }
    }

    // Load recent tracks
    async function loadRecentTracks() {
      debugLog('Loading recent tracks');
      showLoading();
      
      try {
        const recent = await spotifyRequest('/me/player/recently-played?limit=1');
        if (recent && recent.items && recent.items.length > 0) {
          const track = recent.items[0].track;
          debugLog(`Loading recent track: ${track.name}`);
          await loadToDeck('A', track);
          showStatus('Recent track loaded', 'connected');
        } else {
          debugLog('No recent tracks, trying top tracks');
          await loadTopTracks();
        }
      } catch (error) {
        debugLog(`Failed to load recent tracks: ${error.message}`);
        showStatus('Failed to load recent tracks', 'connected');
      } finally {
        hideLoading();
      }
    }

    // Load top tracks
    async function loadTopTracks() {
      debugLog('Loading top tracks');
      showLoading();
      
      try {
        const topTracks = await spotifyRequest('/me/top/tracks?limit=1&time_range=short_term');
        if (topTracks && topTracks.items && topTracks.items.length > 0) {
          const track = topTracks.items[0];
          debugLog(`Loading top track: ${track.name}`);
          await loadToDeck('A', track);
          showStatus('Top track loaded', 'connected');
        } else {
          debugLog('No top tracks available');
          showStatus('No tracks available - start playing music', 'connected');
        }
      } catch (error) {
        debugLog(`Failed to load top tracks: ${error.message}`);
        showStatus('Failed to load tracks', 'connected');
      } finally {
        hideLoading();
      }
    }

    async function loadToDeck(deck, track) {
      if (!track || !track.id) {
        debugLog('Invalid track data provided');
        return;
      }
      
      debugLog(`Loading track to Deck ${deck}: ${track.name} by ${track.artists?.[0]?.name}`);
      showLoading();
      
      try {
        const analysis = await djAI.analyzeForMixing(track.id);
        
        if (deck === 'A') {
          deckA.track = track;
          deckA.analysis = analysis;
          updateDeckDisplay('A', track, analysis);
          debugLog('Track loaded to Deck A successfully');
        } else {
          deckB.track = track;
          deckB.analysis = analysis;
          updateDeckDisplay('B', track, analysis);
          debugLog('Track loaded to Deck B successfully');
        }
        
        generateWaveform(deck);
        
      } catch (error) {
        debugLog(`Failed to load track to deck ${deck}: ${error.message}`);
        showStatus(`Failed to load track to deck ${deck}`, 'connected');
      } finally {
        hideLoading();
      }
    }

    function updateDeckDisplay(deck, track, analysis) {
      const prefix = deck === 'A' ? 'track-a' : 'track-b';
      
      // Safely update track info
      const nameEl = document.getElementById(`${prefix}-name`);
      const artistEl = document.getElementById(`${prefix}-artist`);
      const bpmEl = document.getElementById(`bpm-${deck.toLowerCase()}`);
      const syncEl = document.getElementById(`sync-${deck.toLowerCase()}`);
      
      if (nameEl) nameEl.textContent = track?.name || 'Unknown Track';
      if (artistEl) artistEl.textContent = track?.artists?.[0]?.name || 'Unknown Artist';
      if (bpmEl) bpmEl.textContent = analysis ? analysis.tempo.toFixed(1) : '0.0';
      
      // Update sync status
      if (syncEl && analysis && deckA.analysis && deckB.analysis) {
        const tempoMatch = Math.abs(deckA.analysis.tempo - deckB.analysis.tempo) < 1;
        syncEl.textContent = tempoMatch ? 'SYNCED' : 'NOT SYNCED';
        syncEl.className = tempoMatch ? 'sync-indicator synced' : 'sync-indicator';
      }
      
      debugLog(`Updated display for Deck ${deck}: ${track?.name}`);
    }

    // Enhanced Smart Mix Function
    async function smartMix() {
      if (mixInProgress || !deckA.track || !deckA.analysis) {
        debugLog('Cannot mix - requirements not met');
        return;
      }
      
      mixInProgress = true;
      showStatus('AI Mixing...', 'mixing');
      debugLog('Starting smart mix');
      
      try {
        // Load next track to Deck B if empty
        if (!deckB.track) {
          debugLog('Deck B empty, loading next track');
          const queue = await spotifyRequest('/me/player/queue');
          if (queue?.queue?.length > 0) {
            await loadToDeck('B', queue.queue[0]);
          } else {
            // Try to get a recommended track
            await loadRecentTracks();
          }
        }
        
        if (!deckB.track || !deckB.analysis) {
          throw new Error('No track available for Deck B');
        }
        
        // Simple mix - just skip to next track
        debugLog('Performing track skip');
        await spotifyRequest('/me/player/next', { method: 'POST' });
        
        // Wait for track change
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Swap decks
        const tempDeck = deckA;
        deckA = deckB;
        deckB = { track: null, analysis: null, volume: 0, eq: { high: 0, mid: 0, low: 0 } };
        
        // Update display
        updateDeckDisplay('A', deckA.track, deckA.analysis);
        clearDeckDisplay('B');
        
        showStatus('Mix Complete!', 'connected');
        debugLog('Smart mix completed successfully');
        
      } catch (error) {
        debugLog(`Mix failed: ${error.message}`);
        showStatus('Mix failed - skipping normally', 'connected');
        await spotifyRequest('/me/player/next', { method: 'POST' });
      } finally {
        mixInProgress = false;
      }
    }

    function clearDeckDisplay(deck) {
      const prefix = deck === 'A' ? 'track-a' : 'track-b';
      
      const nameEl = document.getElementById(`${prefix}-name`);
      const artistEl = document.getElementById(`${prefix}-artist`);
      const bpmEl = document.getElementById(`bpm-${deck.toLowerCase()}`);
      const syncEl = document.getElementById(`sync-${deck.toLowerCase()}`);
      
      if (nameEl) nameEl.textContent = 'Empty';
      if (artistEl) artistEl.textContent = 'Load track';
      if (bpmEl) bpmEl.textContent = '0.0';
      if (syncEl) {
        syncEl.textContent = 'NOT SYNCED';
        syncEl.className = 'sync-indicator';
      }
    }

    // UI Control Functions
    function updateCrossfader(value) {
      crossfaderPosition = value;
      document.getElementById('crossfader').value = value;
      
      // Calculate volumes
      deckA.volume = value <= 50 ? 1 : 2 - (value / 50);
      deckB.volume = value >= 50 ? 1 : value / 50;
      
      debugLog(`Crossfader: A=${Math.round(deckA.volume * 100)}%, B=${Math.round(deckB.volume * 100)}%`);
    }

    function toggleAutoMix() {
      autoMixActive = !autoMixActive;
      const btn = document.getElementById('auto-mix-btn');
      btn.classList.toggle('active');
      document.getElementById('auto-mix').textContent = autoMixActive ? 'ON' : 'OFF';
      debugLog(`Auto-mix: ${autoMixActive ? 'ON' : 'OFF'}`);
    }

    function applyEffect(effect) {
      debugLog(`Applying ${effect} effect`);
      // This would apply actual audio effects in a real implementation
    }

    async function loadNextTrack() {
      debugLog('Loading next track to Deck B');
      const queue = await spotifyRequest('/me/player/queue');
      if (queue?.queue?.length > 0) {
        await loadToDeck('B', queue.queue[0]);
      } else {
        await loadRecentTracks();
      }
    }

    async function togglePlayPause() {
      debugLog('Toggling play/pause');
      const playback = await spotifyRequest('/me/player');
      if (playback?.is_playing) {
        await spotifyRequest('/me/player/pause', { method: 'PUT' });
        debugLog('Paused playback');
      } else {
        await spotifyRequest('/me/player/play', { method: 'PUT' });
        debugLog('Started playback');
      }
    }

    // Visualization Functions
    function initializeVisualizers() {
      // Generate initial waveforms
      generateWaveform('A');
      generateWaveform('B');
      
      // Start spectrum analyzer
      setInterval(updateSpectrum, 50);
    }

    function generateWaveform(deck) {
      const container = document.getElementById(`waveform-${deck.toLowerCase()}`);
      if (!container) return;
      
      container.innerHTML = '';
      
      // Generate realistic waveform
      for (let i = 0; i < 200; i++) {
        const bar = document.createElement('div');
        bar.className = 'waveform-bar';
        // Create more realistic waveform pattern
        const height = Math.sin(i * 0.1) * 30 + Math.random() * 50 + 20;
        bar.style.height = height + 'px';
        container.appendChild(bar);
      }
    }

    function updateSpectrum() {
      const spectrum = djAI.getSpectrum();
      const container = document.getElementById('spectrum');
      if (!container) return;
      
      if (container.children.length === 0) {
        // Create bars
        for (let i = 0; i < 32; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          container.appendChild(bar);
        }
      }
      
      // Update bar heights with some animation
      const bars = container.children;
      for (let i = 0; i < bars.length; i++) {
        const targetHeight = (spectrum[i] * 120 + Math.random() * 20 + 10);
        bars[i].style.height = targetHeight + 'px';
      }
    }

    async function updateDJInterface() {
      // Update playback progress
      const playback = await spotifyRequest('/me/player');
      if (playback && playback.item) {
        // Update waveform position
        const progress = playback.progress_ms / playback.item.duration_ms;
        const waveformA = document.getElementById('waveform-a');
        if (waveformA) {
          waveformA.style.transform = `translateX(${-progress * 100}%)`;
        }
        
        // Update play button
        const playBtn = document.getElementById('play-btn');
        if (playBtn) {
          playBtn.textContent = playback.is_playing ? '‚è∏Ô∏è PAUSE' : '‚ñ∂Ô∏è PLAY';
        }
      }
    }

    // Utility Functions
    function showStatus(message, type) {
      const status = document.getElementById('status');
      if (status) {
        status.textContent = message;
        status.className = `status ${type}`;
      }
      debugLog(`Status: ${message}`);
    }

    function showLoading() {
      const overlay = document.getElementById('loading-overlay');
      if (overlay) overlay.classList.add('active');
    }

    function hideLoading() {
      const overlay = document.getElementById('loading-overlay');
      if (overlay) overlay.classList.remove('active');
    }

    function logout() {
      debugLog('Logging out');
      accessToken = null;
      sessionStorage.clear();
      window.location.reload();
    }

    // Initialize on load
    window.onload = async function() {
      debugLog('Application starting');
      const storedToken = sessionStorage.getItem('access_token');
      if (storedToken) {
        debugLog('Found stored token, initializing DJ');
        accessToken = storedToken;
        await initializeDJ();
      } else {
        debugLog('No stored token, checking for redirect');
        await handleRedirect();
      }
    };

    // Event listeners
    document.addEventListener('DOMContentLoaded', function() {
      // Crossfader event listener
      const crossfader = document.getElementById('crossfader');
      if (crossfader) {
        crossfader.addEventListener('input', (e) => {
          updateCrossfader(e.target.value);
        });
      }

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (!accessToken) return;
        
        switch(e.code) {
          case 'Space':
            e.preventDefault();
            togglePlayPause();
            break;
          case 'KeyM':
            e.preventDefault();
            smartMix();
            break;
          case 'KeyA':
            e.preventDefault();
            toggleAutoMix();
            break;
          case 'KeyD':
            e.preventDefault();
            toggleDebug();
            break;
        }
      });
    });
  </script>
</body>
</html>
